Directory structure:
└── storybook/
    ├── README.md
    ├── ChartSizeDimensions.tsx
    ├── global.css
    ├── main.ts
    ├── manager.ts
    ├── preview.ts
    ├── RechartsTheme.ts
    ├── StorybookArgs.ts
    ├── tsconfig.json
    ├── stories/
    │   ├── Blog.mdx
    │   ├── Customise.mdx
    │   ├── GettingStarted.mdx
    │   ├── Installation.mdx
    │   ├── Welcome.mdx
    │   ├── API/
    │   │   ├── Accessibility.mdx
    │   │   ├── ResponsiveContainer.mdx
    │   │   ├── ResponsiveContainer.stories.tsx
    │   │   ├── cartesian/
    │   │   │   ├── Area.mdx
    │   │   │   ├── Area.stories.tsx
    │   │   │   ├── Bar.mdx
    │   │   │   ├── Bar.stories.tsx
    │   │   │   ├── Brush.mdx
    │   │   │   ├── Brush.stories.tsx
    │   │   │   ├── CartesianAxis.mdx
    │   │   │   ├── CartesianAxis.stories.tsx
    │   │   │   ├── CartesianGrid.mdx
    │   │   │   ├── CartesianGrid.stories.tsx
    │   │   │   ├── ErrorBar.mdx
    │   │   │   ├── ErrorBar.stories.tsx
    │   │   │   ├── Funnel.mdx
    │   │   │   ├── Funnel.stories.tsx
    │   │   │   ├── Line.mdx
    │   │   │   ├── Line.stories.tsx
    │   │   │   ├── ReferenceArea.mdx
    │   │   │   ├── ReferenceArea.stories.tsx
    │   │   │   ├── ReferenceDot.mdx
    │   │   │   ├── ReferenceDot.stories.tsx
    │   │   │   ├── ReferenceLine.mdx
    │   │   │   ├── ReferenceLine.stories.tsx
    │   │   │   ├── Scatter.mdx
    │   │   │   ├── Scatter.stories.tsx
    │   │   │   ├── XAxis.mdx
    │   │   │   ├── XAxis.stories.tsx
    │   │   │   ├── YAxis.mdx
    │   │   │   ├── YAxis.stories.tsx
    │   │   │   ├── ZAxis.mdx
    │   │   │   └── ZAxis.stories.tsx
    │   │   ├── chart/
    │   │   │   ├── AreaChart.mdx
    │   │   │   ├── AreaChart.stories.tsx
    │   │   │   ├── BarChart.mdx
    │   │   │   ├── BarChart.stories.tsx
    │   │   │   ├── ComposedChart.mdx
    │   │   │   ├── ComposedChart.stories.tsx
    │   │   │   ├── FunnelChart.mdx
    │   │   │   ├── FunnelChart.stories.tsx
    │   │   │   ├── LineChart.mdx
    │   │   │   ├── LineChart.stories.tsx
    │   │   │   ├── PieChart.mdx
    │   │   │   ├── PieChart.stories.tsx
    │   │   │   ├── RadarChart.mdx
    │   │   │   ├── RadarChart.stories.tsx
    │   │   │   ├── RadialBarChart.mdx
    │   │   │   ├── RadialBarChart.stories.tsx
    │   │   │   ├── Sankey.mdx
    │   │   │   ├── Sankey.stories.tsx
    │   │   │   ├── ScatterChart.mdx
    │   │   │   ├── ScatterChart.stories.tsx
    │   │   │   ├── SunburstChart.mdx
    │   │   │   ├── SunburstChart.stories.tsx
    │   │   │   ├── Treemap.mdx
    │   │   │   └── Treemap.stories.tsx
    │   │   ├── component/
    │   │   │   ├── Cell.mdx
    │   │   │   ├── Cell.stories.tsx
    │   │   │   ├── Label.mdx
    │   │   │   ├── Label.stories.tsx
    │   │   │   ├── LabelList.mdx
    │   │   │   ├── LabelList.stories.tsx
    │   │   │   ├── Legend.mdx
    │   │   │   ├── Legend.stories.tsx
    │   │   │   ├── Text.mdx
    │   │   │   ├── Text.stories.tsx
    │   │   │   ├── Tooltip.mdx
    │   │   │   └── Tooltip.stories.tsx
    │   │   ├── hooks/
    │   │   │   ├── dimensions.mdx
    │   │   │   └── dimensions.stories.tsx
    │   │   ├── polar/
    │   │   │   ├── Pie.mdx
    │   │   │   ├── Pie.stories.tsx
    │   │   │   ├── PolarAngleAxis.mdx
    │   │   │   ├── PolarAngleAxis.stories.tsx
    │   │   │   ├── PolarGrid.mdx
    │   │   │   ├── PolarGrid.stories.tsx
    │   │   │   ├── PolarRadiusAxis.mdx
    │   │   │   ├── PolarRadiusAxis.stories.tsx
    │   │   │   ├── Radar.mdx
    │   │   │   ├── Radar.stories.tsx
    │   │   │   ├── RadialBar.mdx
    │   │   │   └── RadialBar.stories.tsx
    │   │   ├── props/
    │   │   │   ├── ActiveShapeProps.ts
    │   │   │   ├── AnimationProps.ts
    │   │   │   ├── AreaChartProps.ts
    │   │   │   ├── BarChartProps.ts
    │   │   │   ├── CartesianChartProps.ts
    │   │   │   ├── CartesianComponentShared.ts
    │   │   │   ├── ChartProps.ts
    │   │   │   ├── DotProps.ts
    │   │   │   ├── EventHandlers.ts
    │   │   │   ├── LabelListProps.ts
    │   │   │   ├── Legend.ts
    │   │   │   ├── PolarChartProps.ts
    │   │   │   ├── PolarComponentShared.ts
    │   │   │   ├── RadarChartProps.ts
    │   │   │   ├── RadialBarChartProps.ts
    │   │   │   ├── RadialBarProps.ts
    │   │   │   ├── RectangleProps.ts
    │   │   │   ├── ReferenceComponentShared.ts
    │   │   │   ├── SectorProps.ts
    │   │   │   ├── SharedAxisProps.ts
    │   │   │   ├── Styles.ts
    │   │   │   ├── TextProps.ts
    │   │   │   ├── Tooltip.ts
    │   │   │   ├── TooltipProps.tsx
    │   │   │   ├── utils.ts
    │   │   │   ├── XAxisProps.ts
    │   │   │   └── YAxisProps.ts
    │   │   └── shapes/
    │   │       ├── Cross.mdx
    │   │       ├── Cross.stories.tsx
    │   │       ├── Curve.mdx
    │   │       ├── Curve.stories.tsx
    │   │       ├── Dot.mdx
    │   │       ├── Dot.stories.tsx
    │   │       ├── Polygon.mdx
    │   │       ├── Polygon.stories.tsx
    │   │       ├── Rectangle.mdx
    │   │       ├── Rectangle.stories.tsx
    │   │       ├── Sector.mdx
    │   │       └── Sector.stories.tsx
    │   ├── data/
    │   │   ├── BoxPlot.ts
    │   │   ├── Coordinate.ts
    │   │   ├── DataProps.ts
    │   │   ├── Error.ts
    │   │   ├── Impression.ts
    │   │   ├── index.ts
    │   │   ├── NodeAndLink.ts
    │   │   ├── PackageDownloads.ts
    │   │   ├── Page.ts
    │   │   ├── Size.ts
    │   │   ├── solarSystem.ts
    │   │   ├── spurriousCorrelations.ts
    │   │   ├── StockPrice.ts
    │   │   ├── Tick.ts
    │   │   └── Time.ts
    │   └── Examples/
    │       ├── AreaChart.stories.tsx
    │       ├── ChartLayout.stories.tsx
    │       ├── DualLineChart.stories.tsx
    │       ├── LineChart.stories.tsx
    │       ├── RadarChart.stories.tsx
    │       ├── RadialBarChart.stories.tsx
    │       ├── RadialBarChartMultipleAxes.stories.tsx
    │       ├── ScatterChart.stories.tsx
    │       ├── ScatterChartWithTwoErrorBars.stories.tsx
    │       ├── Synchronised.stories.tsx
    │       ├── TimeSeries.stories.tsx
    │       ├── Tooltip.stories.tsx
    │       ├── BarChart/
    │       │   └── BarChart.stories.tsx
    │       ├── cartesian/
    │       │   ├── Area/
    │       │   │   ├── AreaWithCustomDot.stories.tsx
    │       │   │   ├── AreaWithCustomLabel.stories.tsx
    │       │   │   └── AreaWithFillPattern.stories.tsx
    │       │   ├── Bar/
    │       │   │   ├── CustomizedEvent.stories.tsx
    │       │   │   ├── CustomizedShape.stories.tsx
    │       │   │   ├── FillPatternOrGradient.stories.tsx
    │       │   │   ├── StackedAndUnstacked.stories.tsx
    │       │   │   └── WithBrushAndOnDragEnd.stories.tsx
    │       │   ├── Brush/
    │       │   │   ├── Brush.stories.tsx
    │       │   │   └── BrushInSurface.stories.tsx
    │       │   ├── CartesianAxis/
    │       │   │   ├── MultipleAxes.stories.tsx
    │       │   │   └── TickPositioning.stories.tsx
    │       │   ├── Line/
    │       │   │   ├── LineWithCustomDot.stories.tsx
    │       │   │   └── LineWithCustomLabel.stories.tsx
    │       │   ├── ReferenceArea/
    │       │   │   └── ReferenceAreaIfOverflow.stories.tsx
    │       │   ├── ReferenceDot/
    │       │   │   └── ReferenceDotIfOverflow.stories.tsx
    │       │   ├── ReferenceLine/
    │       │   │   ├── ReferenceLineIfOverflow.stories.tsx
    │       │   │   └── ReferenceLineSegment.stories.tsx
    │       │   ├── XAxis/
    │       │   │   ├── SolarSystem.stories.tsx
    │       │   │   ├── XAxisWithCalculatedPadding.stories.tsx
    │       │   │   ├── XAxisWithCustomTicks.stories.tsx
    │       │   │   ├── XAxisWithDifferentDataTypes.stories.tsx
    │       │   │   ├── XAxisWithMultipleAxes.stories.tsx
    │       │   │   └── XAxisWithTickFormatter.stories.tsx
    │       │   └── YAxis/
    │       │       ├── XAxisIncludeHidden.stories.tsx
    │       │       └── YAxisMultipleAxes.stories.tsx
    │       ├── ComposedChart/
    │       │   ├── AccessibilityLayer.stories.tsx
    │       │   ├── BoxPlot.stories.tsx
    │       │   └── StockPrice.stories.tsx
    │       ├── DataKey/
    │       │   └── ToggleBetweenDataKeys.stories.tsx
    │       ├── Pie/
    │       │   ├── CustomActiveShapePieChart.stories.tsx
    │       │   ├── DraggablePie.stories.tsx
    │       │   ├── PieWithCells.stories.tsx
    │       │   ├── PieWithLegend.stories.tsx
    │       │   ├── PieWithNeedle.stories.tsx
    │       │   ├── PieWithStep.stories.tsx
    │       │   └── PieWithTooltip.stories.tsx
    │       └── ResponsiveContainer/
    │           ├── MultiChartFlexbox.stories.tsx
    │           └── style.css
    └── storybook-addon-recharts/
        ├── ArrayInspector.tsx
        ├── CartesianChartInspector.tsx
        ├── constants.ts
        ├── ObjectInspector.tsx
        ├── PolarChartInspector.tsx
        ├── preview.tsx
        ├── RechartsHookInspector.tsx
        ├── register.tsx
        ├── ScaleInspector.tsx
        └── withRechartsHookInspector.tsx


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: storybook/README.md
================================================
# Goal

Storybook is a tool for developing UI components in isolation. It makes building UIs organized and efficient.
It also documents the components and their usage in an interactive way.

We want to migrate our current documentation to Storybook.
The documentation is currently in the form of a static website, with embedded code sandboxes.

## Structure

As we want to migrate existing documentation to Storybook, we will want to reproduce the existing structure:

### API

The API section contains a single story per component. The goal is to communicate a components behaviour as concise and simple as possible.

[`storybook/stories/API/cartesian/Line.stories.tsx`](https://github.com/recharts/recharts/blob/master/storybook/stories/API/cartesian/Line.stories.tsx) can be considered a template for writing stories for the API section.

Acceptance criteria for API stories:

- Each component should be documented in a mdx file.
  - The mdx file should contain a description of the component.
  - The mdx file should list the possible parent components.
  - The mdx file should list the possible child components.
  - The mdx file should list the args in a table, grouped by category.
  - The description of each arg should ideally be auto-generated from the code - see AnimationTiming for example
  ```
     /** The type of easing function to use for animations */
     export type AnimationTiming = 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear';
  ```
  - Some args are documented in the `storybook/stories/API/props/*.ts`.
- should default to be as simple as possible (i.e. no complex interaction effects, no custom components, no custom styling, default behaviour)

### Examples

The examples section contains stories that show how to use recharts in a real world scenario. The goal is to show how to use recharts in a complex scenario, and how to use recharts with other libraries.

A good example of an example story is `storybook/stories/Examples/Pie/PieWithNeedle.stories.tsx`
It shows an non standard usage of a PieChart, with a custom component to achieve a new chart type (Gauge).

Examples stories:

- are not necessarily tied to a single component
- use complex and realistic data
- process data (i.e. histogram, control chart, ...)
- use custom components
- use third party libraries (i.e. d3-scale)
- aim to show the best practice, and best design patterns for using recharts
- are the place to show edge cases, and how to deal with them

## Technical details

We are following the Component Story Format 3. https://storybook.js.org/blog/storybook-csf3-is-here
We are using Storybook 7, and Typescript.

## Best practice

Please follow the acceptance criteria and structure laid out above.
Additionally, please follow the best practices of Storybook:

- https://storybook.js.org/docs/7.0/react/writing-stories/introduction
- https://storybook.js.org/docs/7.0/react/essentials/controls
- https://storybook.js.org/docs/7.0/react/essentials/interactions

When documenting a new component, best:
1 - add a story to the API section - Component.stories.tsx
2 - add a mdx file next to it - Component.mdx - which initially only contains

```mdxjs
import * as ComponentStories from './Component.stories';
<ArgTypes of={ComponentStories} sort={'requiredFirst'}/>
```

Thereby adding the props table to the mdx file.
3 - Add descriptions to the props in the mdx file.

We are using the storybook test runner to test our stories. https://storybook.js.org/docs/react/writing-tests/test-runner#page-top
We integrated it into our CI/CD, and it helps us test interaction effects, and other complex behaviour.

If you can, please do add interactions to the stories, because it helps add confidence to feature work, and it helps us catch bugs.



================================================
FILE: storybook/ChartSizeDimensions.tsx
================================================
import React from 'react';
import { useChartHeight, useChartWidth } from '../src';

/**
 * Renders a line with arrows on left and right.
 * @constructor
 */
function HorizontalLineWithArrows({
  x1,
  x2,
  y,
  label,
  stroke = 'black',
}: {
  x1: number;
  y: number;
  x2: number;
  label: string;
  stroke?: string;
}) {
  const strokeWidth = 2;
  const arrowSize = 7;
  const width = x2 - x1;
  return (
    <>
      <line x1={x1} y1={y} x2={x2} y2={y} stroke={stroke} strokeWidth={strokeWidth} />
      <line x1={x1} y1={y} x2={x1 + arrowSize} y2={y - arrowSize} stroke={stroke} strokeWidth={strokeWidth} />
      <line x1={x1} y1={y} x2={x1 + arrowSize} y2={y + arrowSize} stroke={stroke} strokeWidth={strokeWidth} />
      <line x1={x2} y1={y} x2={x2 - arrowSize} y2={y - arrowSize} stroke={stroke} strokeWidth={strokeWidth} />
      <line x1={x2} y1={y} x2={x2 - arrowSize} y2={y + arrowSize} stroke={stroke} strokeWidth={strokeWidth} />
      {/* 8px margin so that the text is not hugging the line */}
      <text x={width * 0.9} y={y + 8} textAnchor="end" dominantBaseline="hanging" stroke="red">
        {label}
      </text>
    </>
  );
}

function Background({ width, height, label }: { width: number; height: number; label: string }) {
  const patternId = `pattern+${label}`;
  return (
    <svg width={width} height={height} style={{ position: 'absolute', top: 0, left: 0 }}>
      <defs>
        <pattern
          id={patternId}
          x={0}
          y={0}
          width={120}
          height={50}
          patternUnits="userSpaceOnUse"
          patternTransform="rotate(30)"
        >
          <text x={0} y={10} fontSize={24} stroke="#eee" fill="#eee" dominantBaseline="hanging">
            {label.toUpperCase()}
          </text>
        </pattern>
      </defs>
      <rect x={0} y={0} width={width} height={height} fill={`url(#${patternId})`} />
    </svg>
  );
}

function VerticalLineWithArrows({
  x,
  y1,
  y2,
  label,
  stroke = 'black',
}: {
  x: number;
  y1: number;
  y2: number;
  label: string;
  stroke?: string;
}) {
  const strokeWidth = 2;
  const arrowSize = 7;
  const height = y2 - y1;
  return (
    <>
      <line x1={x} y1={y1} x2={x} y2={y2} stroke={stroke} strokeWidth={strokeWidth} />
      <line x1={x} y1={y1} x2={x - arrowSize} y2={y1 + arrowSize} stroke={stroke} strokeWidth={strokeWidth} />
      <line x1={x} y1={y1} x2={x + arrowSize} y2={y1 + arrowSize} stroke={stroke} strokeWidth={strokeWidth} />
      <line x1={x} y1={y2} x2={x - arrowSize} y2={y2 - arrowSize} stroke={stroke} strokeWidth={strokeWidth} />
      <line x1={x} y1={y2} x2={x + arrowSize} y2={y2 - arrowSize} stroke={stroke} strokeWidth={strokeWidth} />
      <text x={x + 8} y={height * 0.8} textAnchor="start" dominantBaseline="middle" stroke="blue">
        {label}
      </text>
    </>
  );
}

export function SvgDimensionShower({ width, height }: { width: number; height: number }) {
  return (
    <svg width={width} height={height} style={{ position: 'absolute', top: 0, left: 0 }}>
      <Background width={width} height={height} label="Chart" />
      <rect
        x={0}
        y={0}
        width={width}
        height={height}
        fill="none"
        stroke="green"
        strokeWidth={5}
        strokeDasharray="3 3"
      />
      <HorizontalLineWithArrows x1={0} y={height * 0.15} x2={width} stroke="red" label={`useChartWidth: ${width}px`} />
      <VerticalLineWithArrows x={width * 0.1} y1={0} y2={height} stroke="blue" label={`useChartHeight: ${height}px`} />
    </svg>
  );
}

export const ChartSizeDimensions = () => {
  const width = useChartWidth();
  const height = useChartHeight();
  return <SvgDimensionShower width={width} height={height} />;
};



================================================
FILE: storybook/global.css
================================================
#storybook-root {
  width: 80%;
  display: flex;
  align-items: center;
  height: calc(100vh - 2rem); /* 1rem is the padding of iframe body */
  margin: auto;
}



================================================
FILE: storybook/main.ts
================================================
module.exports = {
  stories: [
    // The order of stories here reflects the order in the sidebar.
    './stories/Welcome.mdx',
    './stories/Installation.mdx',
    './stories/GettingStarted.mdx',
    './stories/**/*.mdx',
    './stories/**/*.stories.@(ts|tsx)',
  ],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
    '@storybook/addon-interactions',
    '@storybook/addon-a11y',
    '@storybook/addon-storysource',
    '@storybook/addon-docs',
    '@storybook/addon-mdx-gfm',
    '@storybook/addon-webpack5-compiler-swc',
    '@chromatic-com/storybook',
    './storybook-addon-recharts',
  ],
  framework: {
    name: '@storybook/react-webpack5',
    options: {},
  },
  features: {
    interactionsDebugger: true,
  },
  docs: {},
};



================================================
FILE: storybook/manager.ts
================================================
import { addons } from '@storybook/manager-api';
import RechartsTheme from './RechartsTheme';

addons.setConfig({
  theme: RechartsTheme,
});



================================================
FILE: storybook/preview.ts
================================================
import { Decorator, Preview } from '@storybook/react';
import './global.css';
import { DocsPage, DocsContainer } from '@storybook/addon-docs';

const preview: Preview = {
  parameters: {
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/,
      },
    },
    layout: 'padded',
    docs: {
      container: DocsContainer,
      page: DocsPage,
    },
    backgrounds: {
      default: 'light',
    },
    // Sets a delay of 1550ms before each story to give them time to animate (recharts animation default is 1500ms)
    chromatic: { delay: 1550 },
  },
};

export default preview;

export const decorators: Decorator[] = [];



================================================
FILE: storybook/RechartsTheme.ts
================================================
import { create } from '@storybook/theming/create';

export default create({
  base: 'light',
  brandTitle: 'Recharts',
  brandUrl: 'https://recharts.org/en-US/',
  brandTarget: '_self',

  fontBase: '"Source Sans Pro", "Hiragino Sans GB", Arial, sans-serif',
  fontCode: '"Roboto Mono", Consolas, "Liberation Mono", "Courier New", Courier, monospace',

  colorPrimary: '#1281ca',
  colorSecondary: '#2e96ea',

  // UI
  appBg: '#FCFCFC',
  appContentBg: '#ffffff',
  appPreviewBg: '#ffffff',
  appBorderColor: '#eee',
  appBorderRadius: 5,

  // Text colors
  textColor: '#666',
  textInverseColor: '#333',

  // Toolbar default and active colors
  barTextColor: '#333',
  barSelectedColor: '#1181CA',
  barBg: '#FCFCFC',

  // Form colors
  inputBg: '#F5F5F5',
  inputBorder: '#999',
  inputTextColor: '#333',
  inputBorderRadius: 2,
});



================================================
FILE: storybook/StorybookArgs.ts
================================================
import { Args } from '@storybook/react';

/*
 * This is the type as defined here: https://storybook.js.org/docs/react/api/arg-types#argtypes
 * The actual library exports only `interface Args { [name: string]: any; }`.
 * The "any" does not allow your editor to show autocomplete or documentation.
 *
 * This has been reported before: https://github.com/storybookjs/storybook/issues/11916
 * If the official types get updated then we can remove this whole file
 * and import directly Args from '@storybook/react'
 */

export type StorybookArg = {
  description?: string;
  /**
   * This property is not defined in the Storybook Args
   * - but our internal recharts `getStoryArgsFromArgsTypesObject` function reads it.
   */
  defaultValue?: unknown;
  control?: ControlType | { type: ControlType };
  options?: unknown[];
  /**
   * Specifies the semantic type of the argType.
   * When an argType is inferred, the information from the various tools is summarized in this property,
   * which is then used to infer other properties, like control and table.type.
   *
   * If you only need to specify the documented type, you should use `table.type`, instead.
   */
  type?: SBType | SBType['name'];
  table?: {
    defaultValue?: { summary: string; detail?: string } | unknown;
    /**
     * The documented type of the argType.
     * summary is typically used for the type itself,
     * while detail is used for additional information.
     *
     * If you need to specify the actual, semantic type, you should use `type`, instead.
     */
    type?: {
      summary?: string;
      detail?: string;
    };
    category?: 'Content' | 'Styles' | 'Position' | 'Internal' | string;
  };
  hide?: boolean;
  disable?: boolean;
};

/**
 * ArgTypes specify the behavior of args.
 * By specifying the type of an arg, you constrain the values that it can accept
 * and provide information about args that are not explicitly set (i.e., description).
 * You can also use argTypes to “annotate” args with information used by addons that make use of those args.
 * For instance, to instruct the controls addon to render a color picker, you could specify the 'color' control type.
 *
 * See: https://storybook.js.org/docs/react/api/arg-types
 */
export interface StorybookArgs extends Args {
  [name: string]: StorybookArg;
}

/**
 * See https://storybook.js.org/docs/react/api/arg-types#controltype
 */
type ControlType =
  | 'object'
  | 'boolean'
  | 'check'
  | 'inline-check'
  | 'radio'
  | 'inline-radio'
  | 'select'
  | 'multi-select'
  | 'number'
  | 'range'
  | 'file'
  | 'color'
  | 'date'
  | 'text';

interface SBBaseType {
  required?: boolean;
  raw?: string;
}

type SBScalarType = SBBaseType & {
  name: 'boolean' | 'string' | 'number' | 'function' | 'symbol';
};

type SBArrayType = SBBaseType & {
  name: 'array';
  value: SBType;
};
type SBObjectType = SBBaseType & {
  name: 'object';
  value: Record<string, SBType>;
};
type SBEnumType = SBBaseType & {
  name: 'enum';
  value: (string | number)[];
};
type SBIntersectionType = SBBaseType & {
  name: 'intersection';
  value: SBType[];
};
type SBUnionType = SBBaseType & {
  name: 'union';
  value: SBType[];
};
type SBOtherType = SBBaseType & {
  name: 'other';
  value: string;
};

type SBType = SBScalarType | SBEnumType | SBArrayType | SBObjectType | SBIntersectionType | SBUnionType | SBOtherType;



================================================
FILE: storybook/tsconfig.json
================================================
{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "baseUrl": ".",
    "esModuleInterop": true,
    "jsx": "react",
    "module": "commonjs",
    "noEmit": true,
    "noImplicitAny": true,
    "skipLibCheck": true,
    "target": "es6"
  },
  "include": [
    "./**/*",
    "../types.d.ts"
  ]
}



================================================
FILE: storybook/stories/Blog.mdx
================================================



## Awesome React Charts Tips: Gradients, Overlays and Responsive SSR in Recharts
[https://leanylabs.com/blog/awesome-react-charts-tips/](https://leanylabs.com/blog/awesome-react-charts-tips/)

Apply these advanced Recharts library tips to improve your chart`s design and make them SEO-friendly.


## Building a Recharts Dashboard with Cube.js
[https://cube.dev/blog/building-a-recharts-dashboard-with-cube](https://cube.dev/blog/building-a-recharts-dashboard-with-cube)

This tutorial will show you how to build a dashboard using Recharts, a React library that offers you a set of chart components to speed up the creation of a dashboard, and Cube, a Headless BI tool.

## Creating a Football Heat Map React Component with Recharts
[https://medium.com/swlh/creating-a-football-heat-map-react-component-with-recharts-ff310162cee0](https://medium.com/swlh/creating-a-football-heat-map-react-component-with-recharts-ff310162cee0)
Sep 18, 2019

Heat maps are a great visualisation to start with when exploring sports event data that includes coordinates, allowing viewers to immediately focus on areas of the field that matter most.

## 11 Javascript Data Visualization Libraries for 2018
[https://blog.bitsrc.io/11-javascript-charts-and-data-visualization-libraries-for-2018-f01a283a5727?gi=e58122fbdcde](https://blog.bitsrc.io/11-javascript-charts-and-data-visualization-libraries-for-2018-f01a283a5727?gi=e58122fbdcde)
Sep 11, 2018

we can use neat data visualization methods that leverage the brain’s ability to identify and process data in a visual way. To help you get started and easily add beautiful data visualization to your favorite application, here are some of the best Javascript data visualization libraries around in 2018 (unranked). Feel free to comment and add your own suggestions and insights!

## Re-designed Chart for React
[https://medium.com/@arcthur/re-designed-chart-for-react-fbb31cf78415#.gc1k19sdv](https://medium.com/@arcthur/re-designed-chart-for-react-fbb31cf78415#.gc1k19sdv)
Jan 29, 2016

Over the past few years, our team were satisfied with React and Redux in some projects, which are almost web applications involved to data presentation or operation. The projects need use a lot of charts which is so painful that we decided to create new chart library for React...




================================================
FILE: storybook/stories/Customise.mdx
================================================
import { pageData as data } from './data/Page';
import { LineChart, Line, CartesianGrid, XAxis, YAxis, Tooltip, BarChart, Bar, Legend  } from '../../src';

export const getIntroOfPage = (label) =>{
if (label === 'Page A') {
return 'Page A is about mens clothing';
} if (label === 'Page B') {
return 'Page B is about womens dress';
} if (label === 'Page C') {
return 'Page C is about womens bag';
} if (label === 'Page D') {
return 'Page D is about household goods';
} if (label === 'Page E') {
return 'Page E is about food';
} if (label === 'Page F') {
return 'Page F is about baby food';
}
};
export const getPath = (x, y, width, height) => (
  `M${x},${y + height}
   C${x + width / 3},${y + height} ${x + width / 2},${y + height / 3} ${x + width / 2}, ${y}
   C${x + width / 2},${y + height / 3} ${x + 2 * width / 3},${y + height} ${x + width}, ${y + height}
   Z`
);
export const CustomizedAxisTick = (...args)=>{
  const {  x, y, stroke, payload } = args[0];
  return (
    <g transform={`translate(${x},${y})`}>
      <text x={0} y={0} dy={16} textAnchor="end" fill="#666" transform="rotate(-35)">
        {payload.value}
      </text>
    </g>
  );
};
export const renderCustomBarLabel = ({ payload, x, y, width, height, value }) => {
  return <text x={x + width / 2} y={y} fill="#666" textAnchor="middle" dy={-6}>{`value: ${value}`}</text>;
};
export const CustomTooltip = ({ payload, label, active }) => {
  if (active) {
    return (
      <div className="custom-tooltip">
        <p className="label">{`${label} : ${payload[0].value}`}</p>
        <p className="intro">{getIntroOfPage(label)}</p>
        <p className="desc">Anything you want can be displayed here.</p>
      </div>
    );
  }
  else{
    return <></>;
  }
};
export const TriangleBar = (...args) => {
  const {
    fill, x, y, width, height,
  } = args[0];

  return <path d={getPath(x, y, width, height)} stroke="none" fill={fill} />;
};


# Customize
## Labels of line, area, bar, axis can be customized
For example, we can create a bar with customized label and customized axis tick.

```tsx
import { BarChart, Bar, XAxis, YAxis } from 'recharts';
const CustomizedAxisTick = (...args)=>{
  const {  x, y, stroke, payload } = args[0];
  return (
    <g transform={`translate(${x},${y})`}>
      <text x={0} y={0} dy={16} textAnchor="end" fill="#666" transform="rotate(-35)">
        {payload.value}
      </text>
    </g>
  );
};
const renderCustomBarLabel = ({ payload, x, y, width, height, value }) => {
  return <text x={x + width / 2} y={y} fill="#666" textAnchor="middle" dy={-6}>{`value: ${value}`}</text>;
};
const renderBarChart = (
  <BarChart width={600} height={300} data={data} margin={{ top: 5, right: 20, left: 10, bottom: 20 }}>
    <XAxis dataKey="name" tick={<CustomizedAxisTick/>}
    <YAxis />
    <Bar dataKey="uv" barSize={30} fill="#8884d8" label={renderCustomBarLabel}/>
  </BarChart>
);
```

<BarChart width={600} height={300} data={data} margin={{ top: 5, right: 20, left: 10, bottom: 20 }}>
  <XAxis dataKey="name" tick={<CustomizedAxisTick/>} />
  <YAxis />
  <Bar dataKey="uv" barSize={30} fill="#8884d8"
       label={renderCustomBarLabel}/>
</BarChart>

## The shape of bar can be customized
The props shape of `<Bar />` can be set to be a function or a react element to render customized shape.

```tsx
import { BarChart, Bar, XAxis, YAxis } from 'recharts';
const getPath = (x, y, width, height) => (
  `M${x},${y + height}
   C${x + width / 3},${y + height} ${x + width / 2},${y + height / 3} ${x + width / 2}, ${y}
   C${x + width / 2},${y + height / 3} ${x + 2 * width / 3},${y + height} ${x + width}, ${y + height}
   Z`
);

const TriangleBar = (props) => {
const {
fill, x, y, width, height,
} = props;

return <path d={getPath(x, y, width, height)} stroke="none" fill={fill} />;
};
const renderBarChart = (
<BarChart width={600} height={300} data={data} margin={{ top: 5, right: 20, left: 10, bottom: 20 }}>
  <XAxis dataKey="name" tick={<CustomizedAxisTick/>} />
  <YAxis />
  <Bar dataKey="uv" fill="#8884d8"
       shape={<TriangleBar />} />
</BarChart>
);
```

## The content of tooltip can be customized
Sometimes we may want tooltip to display much more information.

```tsx
import { BarChart, Bar, XAxis, YAxis, Tooltip } from 'recharts';
...
function getIntroOfPage(label) {
  if (label === 'Page A') {
    return 'Page A is about men's clothing';
  } if (label === 'Page B') {
    return 'Page B is about women's dress';
  } if (label === 'Page C') {
    return 'Page C is about women's bag';
  } if (label === 'Page D') {
    return 'Page D is about household goods';
  } if (label === 'Page E') {
    return 'Page E is about food';
  } if (label === 'Page F') {
    return 'Page F is about baby food';
  }
}

function CustomTooltip({ payload, label, active }) {
if (active) {
return (
<div className="custom-tooltip">
<p className="label">{`${label} : ${payload[0].value}`}</p>
<p className="intro">{getIntroOfPage(label)}</p>
<p className="desc">Anything you want can be displayed here.</p>
</div>
);
}

return null;
}
const renderBarChart = (
<BarChart width={600} height={300} data={data} margin={{ top: 5, right: 20, left: 10, bottom: 20 }}>
  <XAxis dataKey="name" tick={<CustomizedAxisTick/>} />
  <YAxis />
  <Tooltip content={<CustomTooltip />}/>
  <Bar dataKey="uv" fill="#8884d8"
       shape={<TriangleBar />} />
</BarChart>
);
```

<BarChart width={600} height={300} data={data} margin={{ top: 5, right: 20, left: 10, bottom: 20 }}>
  <XAxis dataKey="name" tick={<CustomizedAxisTick/>} />
  <YAxis />
  <Tooltip content={<CustomTooltip />}/>
  <Bar dataKey="uv" fill="#8884d8"
       shape={<TriangleBar />} />
</BarChart>

## The style of each chart element can be customized
Except tooltip and legend, all the element in a chart is drawn by svg element. So you can change the attributes of each chart element conveniently.

```tsx
import { BarChart, Bar, XAxis, YAxis, Tooltip, CartesianGrid } from 'recharts';

const renderBarChart = (
<BarChart width={600} height={300} data={data} margin={{ top: 5, right: 20, left: 10, bottom: 20 }}>
  <XAxis dataKey="name" stroke="#8884d8" />
  <YAxis />
  <Tooltip />
  <CartesianGrid stroke="#ccc" strokeDasharray="5 5" />
  <Bar dataKey="uv" fill="#8884d8" barSize={30} />
</BarChart>
);
```

<BarChart width={600} height={300} data={data} margin={{ top: 5, right: 20, left: 10, bottom: 20 }}>
  <XAxis dataKey="name" stroke="#8884d8" />
  <YAxis />
  <Tooltip />
  <CartesianGrid stroke="red" strokeDasharray="5 5" />
  <Bar dataKey="uv" fill="green" barSize={30} />
</BarChart>

## The style of tooltip, legend can be customized
Though tooltip, legend are drawn by svg elements, you may change the style of tooltip, legend by the apis we offer. of cource, you can change the style in css too.

```tsx
import { BarChart, Bar, XAxis, YAxis, Tooltip, Legend, CartesianGrid } from 'recharts';

const renderBarChart = (
<BarChart width={600} height={300} data={data} margin={{ top: 5, right: 20, left: 10, bottom: 20 }}>
  <XAxis dataKey="name" stroke="#8884d8" />
  <YAxis />
  <Tooltip wrapperStyle={{ width: 100, backgroundColor: '#ccc' }} />
  <Legend width={100} wrapperStyle={{ top: 40, right: 20, backgroundColor: '#f5f5f5', border: '1px solid #d5d5d5', borderRadius: 3, lineHeight: '40px' }} />
  <CartesianGrid stroke="#ccc" strokeDasharray="5 5" />
  <Bar dataKey="uv" fill="#8884d8" barSize={30} />
</BarChart>
);
```

<BarChart width={600} height={300} data={data} margin={{ top: 5, right: 20, left: 10, bottom: 20 }}>
  <XAxis dataKey="name" stroke="#8884d8" />
  <YAxis />
  <Tooltip wrapperStyle={{ width: 100, backgroundColor: '#ccc' }} />
  <Legend width={100} wrapperStyle={{ top: 40, right: 20, backgroundColor: '#f5f5f5', border: '1px solid #d5d5d5', borderRadius: 3, lineHeight: '40px' }} />
  <CartesianGrid stroke="#ccc" strokeDasharray="5 5" />
  <Bar dataKey="uv" fill="#8884d8" barSize={30} />
</BarChart>



================================================
FILE: storybook/stories/GettingStarted.mdx
================================================
import { pageData as data } from './data/Page';
import { LineChart, Line, CartesianGrid, XAxis, YAxis, Tooltip } from '../../src';

# Getting started

## Choose the type of chart you need.

With the help of babel-plugin-recharts, we can import components we actually need, making the project smaller than otherwise.
Generate a simple chart by using plain javascript data (usually an array of objects).

```tsx
const data = [{name: 'Page A', uv: 400, pv: 2400, amt: 2400}, ...];
```

```tsx
import { LineChart, Line } from 'recharts';
const renderLineChart = (
<LineChart width={400} height={400} data={data}>
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
</LineChart>
);
```

<LineChart width={400} height={400} data={data}>
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
</LineChart>

## Add components that you want to be drawn
LineChart can have XAxis, YAxis, Legend, CartesianGrid and so on.

```tsx
import { LineChart, Line, CartesianGrid, XAxis, YAxis } from 'recharts';
const renderLineChart = (
<LineChart width={600} height={300} data={data}>
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
  <CartesianGrid stroke="#ccc" />
  <XAxis dataKey="name" />
  <YAxis />
</LineChart>
);
```

<LineChart width={600} height={300} data={data}>
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
  <CartesianGrid stroke="#ccc" />
  <XAxis dataKey="name" />
  <YAxis />
</LineChart>

## Adjust the props of some components
For example, margin-right should be bigger in order to display the right-most x-axis label and the stroke style of the cartesian grid can be dashed for better readability.

```tsx
import { LineChart, Line, CartesianGrid, XAxis, YAxis } from 'recharts';
const renderLineChart = (
<LineChart width={600} height={300} data={data} margin={{ top: 5, right: 20, bottom: 5, left: 0 }}>
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
  <CartesianGrid stroke="#ccc" strokeDasharray="5 5" />
  <XAxis dataKey="name" />
  <YAxis />
</LineChart>
);
```

<LineChart width={600} height={300} data={data} margin={{ top: 5, right: 20, bottom: 5, left: 0 }}>
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
  <CartesianGrid stroke="#ccc" strokeDasharray="5 5" />
  <XAxis dataKey="name" />
  <YAxis />
</LineChart>

## Add interactions
We can easily drop-in a Tooltip component and have rich hovering tooltip functionality.

```tsx
import { LineChart, Line, CartesianGrid, XAxis, YAxis, Tooltip } from 'recharts';
const renderLineChart = (
<LineChart width={600} height={300} data={data} margin={{ top: 5, right: 20, bottom: 5, left: 0 }}>
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
  <CartesianGrid stroke="#ccc" strokeDasharray="5 5" />
  <XAxis dataKey="name" />
  <YAxis />
  <Tooltip />
</LineChart>
);
```

<LineChart width={600} height={300} data={data} margin={{ top: 5, right: 20, bottom: 5, left: 0 }}>
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
  <CartesianGrid stroke="#ccc" strokeDasharray="5 5" />
  <XAxis dataKey="name" />
  <YAxis />
  <Tooltip />
</LineChart>

## Customize your components
For example, you can edit your x-axis label very easily by passing in a custom axis tick render function. You can do similar things with other graphs as well, such as custom shapes for bar charts and much more!

```tsx
import React, { PureComponent } from 'react';
import { LineChart, Line, CartesianGrid, XAxis, YAxis, Tooltip } from 'recharts';

const CustomizedAxisTick = (...args)=>{
  const {  x, y, stroke, payload } = args[0];
  return (
      <g transform={`translate(${x},${y})`}>
        <text x={0} y={0} dy={16} textAnchor="end" fill="#666" transform="rotate(-35)">
          {payload.value}
        </text>
      </g>
    );
};

const renderLineChart = (
<LineChart width={600} height={300} data={data} margin={{ top: 5, right: 20, bottom: 5, left: 0 }}>
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
  <CartesianGrid stroke="#ccc" strokeDasharray="5 5" />
  <XAxis dataKey="name" tick={<CustomizedAxisTick />} />
  <YAxis />
  <Tooltip />
</LineChart>
);
```

export const CustomizedAxisTick = (...args)=>{
  const {  x, y, stroke, payload } = args[0];
  return (
      <g transform={`translate(${x},${y})`}>
        <text x={0} y={0} dy={16} textAnchor="end" fill="#666" transform="rotate(-35)">
          {payload.value}
        </text>
      </g>
    );
};


<LineChart width={600} height={300} data={data} margin={{ top: 5, right: 20, bottom: 20, left: 0 }}>
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
  <CartesianGrid stroke="#ccc" strokeDasharray="5 5" />
  <XAxis dataKey="name" tick={<CustomizedAxisTick/>} />
  <YAxis />
  <Tooltip />
</LineChart>







================================================
FILE: storybook/stories/Installation.mdx
================================================
# Installation

### NPM

NPM is the easiest and fastest way to get started using Recharts. It is also the recommended installation method when building single-page applications (SPAs). It pairs nicely with a CommonJS module bundler such as Webpack.

```bash
#latest stable
npm install recharts
```

### UMD

The UMD build is also available on unpkg.com ( unpkg ):

```html
<script src="https://unpkg.com/react/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/prop-types/prop-types.min.js"></script>
<script src="https://unpkg.com/recharts/umd/Recharts.js"></script>

```
You can find the library on window.Recharts

###  Dev Build

```bash
git clone https://github.com/recharts/recharts.git
cd recharts
npm install
npm run build
```



================================================
FILE: storybook/stories/Welcome.mdx
================================================
import { CartesianGrid, Line, LineChart, XAxis, YAxis, Tooltip } from '../../src';
import { pageData as data } from './data/Page';

# Recharts
A composable charting library built on React components
<LineChart width={500}
           height={300}
           data={data}
           accessibilityLayer
           margin={{
             top: 5,
             right: 5,
             bottom: 5,
             left: 0,
           }}>
  <CartesianGrid stroke="#eee" strokeDasharray="5 5" />
  <XAxis dataKey="name" />
  <YAxis />
  <Line type="monotone" dataKey="uv" stroke="#8884d8" />
  <Line type="monotone" dataKey="pv" stroke="#82ca9d" />
  <Tooltip />
</LineChart>

```typescript jsx
  <LineChart width={500} height={300} data={data} accessibilityLayer>
    <XAxis dataKey="name"/>
    <YAxis/>
    <CartesianGrid stroke="#eee" strokeDasharray="5 5"/>
    <Line type="monotone" dataKey="uv" stroke="#8884d8" />
    <Line type="monotone" dataKey="pv" stroke="#82ca9d" />
    <Tooltip/>
  </LineChart>
```
<iframe src="https://ghbtns.com/github-btn.html?user=recharts&repo=recharts&type=star&count=true&size=median"
        frameBorder="0"
        scrolling="0"
        width="150"
        height="20"
        title="GitHub" />
[![Size](https://badgen.net/bundlephobia/minzip/recharts)](https://bundlephobia.com/package/recharts)
[![Build Status](https://github.com/recharts/recharts/workflows/Node.js%20CI/badge.svg)](https://github.com/recharts/recharts/actions)
[![Coverage Status](https://coveralls.io/repos/recharts/recharts/badge.svg?branch=master&service=github)](https://coveralls.io/github/recharts/recharts?branch=master)
[![npm version](https://badge.fury.io/js/recharts.svg)](http://badge.fury.io/js/recharts)
[![npm downloads](https://img.shields.io/npm/dm/recharts.svg?style=flat-square)](https://www.npmjs.com/package/recharts)
[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg?style=flat)](/LICENSE)



================================================
FILE: storybook/stories/API/Accessibility.mdx
================================================
import { curveCardinal } from 'victory-vendor/d3-shape';
import { CartesianGrid, ResponsiveContainer, Tooltip, XAxis, YAxis, LineChart, Line, Brush } from '../../../src';
import { pageData } from '../data';
import { CategoricalChartProps } from './props/ChartProps';

# Keyboard Accessibility

Anything that a user can do with a mouse, a user should also be able to do using only the keyboard. This is a fundamental requirement for anyone looking to make their software accessibility, and is expanded on in the [W3C's WCAG 2.1.1 success criteria](https://www.w3.org/WAI/WCAG21/Understanding/keyboard.html).

While keyboard-only access is not available out of the box, you can turn on support for keyboard interactions using the `accessibilityLayer` prop. The accessibility layer adds the chart to the tab order, and adds keyboard event handler to listen for arrow keys. This will quickly and easily support accessibility for keyboard-only users.

To see how this works, try the following chart, where the accessibility layer has been applied. You can press the TAB key until you reach the chart. When you see a black border appear around the chart, the chart is "in focus". Once in focus, you can press the left or right arrow key to navigate between individual points. As you navigate, the tooltip will appear at each point, providing access to underlying data.

<ResponsiveContainer width="100%" height={400}>
    <LineChart
        data={pageData}
        title="Line chart showing UV values for pages"
        accessibilityLayer
    >
        <Line type="monotone" dataKey="uv" stroke="#82ca9d" />
        <XAxis dataKey="name" />
        <YAxis />
        <Tooltip />
        <Brush />
    </LineChart>
</ResponsiveContainer>

This chart also contains a "brush", a range slider that lets you control what appears on the X-axis. You can tab to the "travellers" on the brush, and use the left/right arrow keys to adjust them.

The code to generate this example is:
```jsx
<ResponsiveContainer width="100%" height={400}>
    <LineChart
        data={pageData}
        title="Line chart showing UV values for pages"
        accessibilityLayer
    >
        <Line type="monotone" dataKey="uv" stroke="#82ca9d" />
        <XAxis dataKey="name" />
        <YAxis />
        <Tooltip />
    </LineChart>
</ResponsiveContainer>
```

The accessibility layer is not currently available for all charts. The accessibility layer can only be used under the following conditions:
1. The chart must be categorical. This includes: AreaChart, BarChart, ComposedChart, and LineChart.
2. The chart must include a tooltip.
3. The chart must have a horizontal layout.

## Screen reader support
The accessibility layer works with the tooltip to provide feedback to screen reader users.

If you are using a default tooltip, it will work with the `accessibilityLayer` to support screen reader users. The default tooltip will turn into a "live region", which means that screen readers will read the contents of the region as it updates. This will give blind users access to the underlying data in a chart, alongside sighted users.

If you are building your own custom tooltip, you can turn it into a live region by using the attributes `role="status" aria-live="assertive"`. Keep in mind that the full content of the tooltip will be read for every data point that the user interacts with, so it's best practices to keep the content in the tooltip to a minimum.

## Technical notes

When you apply the `accessibilityLayer` to a chart, it will do a couple of things:
1. By default, it will set the `role="application"`. This can be overwritten if you pass in your own `role` prop.
2. By default, it will set the `tabIndex={0}`. This can be overwritten if you pass in your own `tabIndex` prop.

The accessibility layer works by spoofing mouse movements. 
The layer adds an `onKeyDown` handler to intercept `ArrowLeft` and `ArrowRight` keys. 
These keystrokes will then be transformed into mouse movements. 
This means that if you are using `onMouseMove` in addition to `accessibilityLayer`, the `onMouseMove` callback will be fired when the user presses the left and right arrow keys.


================================================
FILE: storybook/stories/API/ResponsiveContainer.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './ResponsiveContainer.stories';

# ResponsiveContainer

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

This is a component that can be used to render charts that will be responsive to its parent.
When you render a chart you have to specify its **width** and **height** for the chart to be
created correctly and show up when rendered. If you want to render a chart that one or both
of the dimensions is not a hard-coded number, instead it can fill the container, or be half
of its parent, then ResponsiveContainer is the right tool for you.

ResponsiveContainer required to have either **width** or **height** or both be a percentage, like
`75%`, if you're trying to specify both width and height to be just a number, then its highly
likely that you don't need ResponsiveContainer and you can render the chart as is.

```jsx
<ResponsiveContainer width="100%" height={400}>
  <LineChart {...args}>
    <Line dataKey="uv" />
  </LineChart>
</ResponsiveContainer>
```

Its worth noting that by default, ResponsiveContainer does not render when you're rendering on
the server (SSR) or if JavaScript is disabled. This is because it depends on browser APIs
like [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) to
first calculate what the percentage equals to in terms of its parent element. For example
if you specify `width="80%"`, ResponsiveContainer should first calculate the width of the
parent, say its `720px`, now it has to calculate 80 percent of that 720 which will be **576px**
and only then, renders the child Chart and passes the calculated width to it. So when you're
rendering a Chart inside ResponsiveContainer, you can omit its width and height and specify
those on the ResponsiveContainer.

If you're using ResponsiveContainer and you're rendering on the server (SSR), then initially on
the Browser, the chart will not be shown until after hydration.
As mentioned, this is because while rendering on server, the dimensions cannot be calculated,
but if you need to have the chart rendered before hydration, you can pass `initialDimension`
prop, which is an object like `{ width: 500, height: 500 }`, when passed, the chart will
be rendered as a 500x500, when hydrated the actual width and height will be re-calculated
and the chart will change to its new dimensions.

```jsx
<ResponsiveContainer width="100%" height={400} initialDimension={{ width: 520, height: 400 }}>
  <LineChart {...args}>
    <Line dataKey="uv" />
  </LineChart>
</ResponsiveContainer>
```

> Note: Try to pass initial dimensions with accurate numbers, otherwise you might add some
> [content layout shift](https://web.dev/cls) which could be annoying for your users.

## Parent Component

It can be used anywhere you would render another React component.

## Child component

The ResponsiveContainer can be used to render recharts charts as
well as any child that needs to know the dimensions of its parent container.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/ResponsiveContainer.stories.tsx
================================================
import React from 'react';
import type { StoryObj } from '@storybook/react';
import { Area, AreaChart, CartesianGrid, ResponsiveContainer, Tooltip, XAxis, YAxis } from '../../../src';
import { pageData } from '../data/Page';

export default {
  component: ResponsiveContainer,
  docs: {
    autodocs: false,
  },
};

export const API: StoryObj<typeof ResponsiveContainer> = {
  args: {
    width: '100%',
    height: 400,
  },
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer {...args}>
        <AreaChart
          width={500}
          height={400}
          data={pageData}
          margin={{
            top: 10,
            right: 30,
            left: 0,
            bottom: 0,
          }}
        >
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="name" />
          <YAxis />
          <Area type="monotone" dataKey="uv" stroke="#8884d8" fill="#8884d8" />
          <Tooltip />
        </AreaChart>
      </ResponsiveContainer>
    );
  },
};



================================================
FILE: storybook/stories/API/cartesian/Area.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Area.stories';

# Area

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component
The Area can be used within a `<ComposedChart/>` or a `<AreaChart/>`.

## Child component
The Area can be used with the following child components: `<LabelList/>`

## Properties
The following table shows a complete list of all properties of the Area.
Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />




================================================
FILE: storybook/stories/API/cartesian/Area.stories.tsx
================================================
import React from 'react';
import { ComposedChart, Area, ResponsiveContainer, Legend, Tooltip, XAxis, YAxis } from '../../../../src';
import { pageData } from '../../data';
import { LineStyle } from '../props/Styles';
import { AnimationProps } from '../props/AnimationProps';
import { legendType } from '../props/Legend';
import { General as GeneralProps, data } from '../props/CartesianComponentShared';
import { ResponsiveProps } from '../props/Tooltip';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';

const AreaSpecificProps = {
  // These two props are not documented on the website. Further investigation is required to document them.
  baseValue: { table: { category: 'Other' } },
  isRange: { table: { category: 'Other' } },
  stackId: {
    description: `The id of group which this area should be stacked into. If no id is specified,
    the area will not be stacked. When two components have the same value axis and same stackId,
    then they are stacked in order.`,
    table: {
      type: {
        summary: 'string | number',
      },
      category: 'General',
    },
  },
};

export default {
  component: Area,
  argTypes: {
    ...AreaSpecificProps,
    ...LineStyle,
    ...AnimationProps,
    legendType,
    ...GeneralProps,
    data,
    ...ResponsiveProps,
    // Other
    baseLine: { table: { category: 'Other' } },
  },
};

const [surfaceWidth, surfaceHeight] = [600, 300];

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <ComposedChart
          width={surfaceWidth}
          height={surfaceHeight}
          margin={{
            top: 20,
            right: 20,
            bottom: 20,
            left: 20,
          }}
          data={pageData}
        >
          {/* All components are added to show the interaction with the Area properties */}
          <Area fill="red" stackId="1" dataKey="pv" />
          <Legend />
          <XAxis dataKey="name" />
          <YAxis />
          {/* The target component */}
          <Area dataKey="uv" {...args} />
          <Tooltip />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    // This API story should have explicit values for all props
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    ...getStoryArgsFromArgsTypesObject(LineStyle),
    ...getStoryArgsFromArgsTypesObject(ResponsiveProps),
    ...getStoryArgsFromArgsTypesObject(AnimationProps),
    isAnimationActive: true,
    type: 'linear',
    connectNulls: true,
    stroke: 'red',
    fill: 'teal',
    strokeDasharray: '4 1',
    label: { fill: 'red', fontSize: 20 },
    dot: { stroke: 'green', strokeWidth: 2 },
    activeDot: { stroke: 'green', strokeWidth: 2 },
    tooltipType: 'responsive',
    dataKey: 'uv',
    unit: ' Visitors',
    stackId: 1,
  },
};



================================================
FILE: storybook/stories/API/cartesian/Bar.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Bar.stories';

# Bar

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component

The Bar can be used within a `<BarChart/>` or a `<ComposedChart/>`.

## Child component

The Bar can be used with the following child components: `<Cell />`, `<LabelList/>` or a `<ErrorBar/>`

## Properties
The following table shows a complete list of all properties of the component.
Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/cartesian/Bar.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { General as GeneralProps } from '../props/CartesianComponentShared';
import {
  ComposedChart,
  Bar,
  ResponsiveContainer,
  Legend,
  Tooltip,
  XAxis,
  YAxis,
  BarChart,
  CartesianGrid,
  LabelList,
} from '../../../../src';
import { pageData } from '../../data';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import {
  onAbort,
  onAbortCapture,
  onAnimationEnd,
  onAnimationEndCapture,
  onAnimationIteration,
  onAnimationIterationCapture,
  onAnimationStart,
  onAnimationStartCapture,
  onAuxClick,
  onAuxClickCapture,
  onBeforeInput,
  onBeforeInputCapture,
  onBlur,
  onBlurCapture,
  onCanPlay,
  onCanPlayCapture,
  onCanPlayThrough,
  onCanPlayThroughCapture,
  onChange,
  onChangeCapture,
  onClick,
  onClickCapture,
  onCompositionEnd,
  onCompositionEndCapture,
  onCompositionStart,
  onCompositionStartCapture,
  onCompositionUpdate,
  onCompositionUpdateCapture,
  onContextMenu,
  onContextMenuCapture,
  onCopy,
  onCopyCapture,
  onCut,
  onCutCapture,
  onDoubleClick,
  onDoubleClickCapture,
  onDrag,
  onDragCapture,
  onDragEnd,
  onDragEndCapture,
  onDragEnter,
  onDragEnterCapture,
  onDragExit,
  onDragExitCapture,
  onDragLeave,
  onDragLeaveCapture,
  onDragOver,
  onDragOverCapture,
  onDragStart,
  onDragStartCapture,
  onDrop,
  onDropCapture,
  onDurationChange,
  onDurationChangeCapture,
  onEmptied,
  onEmptiedCapture,
  onEncrypted,
  onEncryptedCapture,
  onEnded,
  onEndedCapture,
  onError,
  onErrorCapture,
  onFocus,
  onFocusCapture,
  onGotPointerCapture,
  onGotPointerCaptureCapture,
  onInput,
  onInputCapture,
  onInvalid,
  onInvalidCapture,
  onKeyDown,
  onKeyDownCapture,
  onKeyPress,
  onKeyPressCapture,
  onKeyUp,
  onKeyUpCapture,
  onLoad,
  onLoadCapture,
  onLoadedData,
  onLoadedDataCapture,
  onLoadedMetadata,
  onLoadedMetadataCapture,
  onLoadStart,
  onLoadStartCapture,
  onLostPointerCapture,
  onLostPointerCaptureCapture,
  onMouseDown,
  onMouseDownCapture,
  onMouseEnter,
  onMouseLeave,
  onMouseMove,
  onMouseMoveCapture,
  onMouseOut,
  onMouseOutCapture,
  onMouseOver,
  onMouseOverCapture,
  onMouseUp,
  onMouseUpCapture,
  onPaste,
  onPasteCapture,
  onPause,
  onPauseCapture,
  onPlay,
  onPlayCapture,
  onPlaying,
  onPlayingCapture,
  onPointerCancel,
  onPointerCancelCapture,
  onPointerDown,
  onPointerDownCapture,
  onPointerEnter,
  onPointerEnterCapture,
  onPointerLeave,
  onPointerLeaveCapture,
  onPointerMove,
  onPointerMoveCapture,
  onPointerOut,
  onPointerOutCapture,
  onPointerOver,
  onPointerOverCapture,
  onPointerUp,
  onPointerUpCapture,
  onProgress,
  onProgressCapture,
  onRateChange,
  onRateChangeCapture,
  onReset,
  onResetCapture,
  onScroll,
  onScrollCapture,
  onSeeked,
  onSeekedCapture,
  onSeeking,
  onSeekingCapture,
  onSelect,
  onSelectCapture,
  onStalled,
  onStalledCapture,
  onSubmit,
  onSubmitCapture,
  onSuspend,
  onSuspendCapture,
  onTimeUpdate,
  onTimeUpdateCapture,
  onTouchCancel,
  onTouchCancelCapture,
  onTouchEnd,
  onTouchEndCapture,
  onTouchMove,
  onTouchMoveCapture,
  onTouchStart,
  onTouchStartCapture,
  onTransitionEnd,
  onTransitionEndCapture,
  onVolumeChange,
  onVolumeChangeCapture,
  onWaiting,
  onWaitingCapture,
  onWheel,
  onWheelCapture,
} from '../props/EventHandlers';
import { legendType } from '../props/Legend';
import { GeneralStyle, hide } from '../props/Styles';
import {
  animationBegin,
  animationDuration,
  animationEasing,
  AnimationProps,
  isAnimationActive,
} from '../props/AnimationProps';

const [surfaceWidth, surfaceHeight] = [600, 300];

// Only these event handlers are supported for the Bar component
const EventHandlersForBar = {
  onAbort,
  onAbortCapture,
  onAnimationEnd,
  onAnimationEndCapture,
  onAnimationIteration,
  onAnimationIterationCapture,
  onAnimationStart,
  onAnimationStartCapture,
  onAuxClick,
  onAuxClickCapture,
  onBeforeInput,
  onBeforeInputCapture,
  onBlur,
  onBlurCapture,
  onCanPlay,
  onCanPlayCapture,
  onCanPlayThrough,
  onCanPlayThroughCapture,
  onChange,
  onChangeCapture,
  onClick,
  onClickCapture,
  onCompositionEnd,
  onCompositionEndCapture,
  onCompositionStart,
  onCompositionStartCapture,
  onCompositionUpdate,
  onCompositionUpdateCapture,
  onContextMenu,
  onContextMenuCapture,
  onCopy,
  onCopyCapture,
  onCut,
  onCutCapture,
  onDoubleClick,
  onDoubleClickCapture,
  onDrag,
  onDragCapture,
  onDragEnd,
  onDragEndCapture,
  onDragEnter,
  onDragEnterCapture,
  onDragExit,
  onDragExitCapture,
  onDragLeave,
  onDragLeaveCapture,
  onDragOver,
  onDragOverCapture,
  onDragStart,
  onDragStartCapture,
  onDrop,
  onDropCapture,
  onDurationChange,
  onDurationChangeCapture,
  onEmptied,
  onEmptiedCapture,
  onEncrypted,
  onEncryptedCapture,
  onEnded,
  onEndedCapture,
  onError,
  onErrorCapture,
  onFocus,
  onFocusCapture,
  onGotPointerCapture,
  onGotPointerCaptureCapture,
  onInput,
  onInputCapture,
  onInvalid,
  onInvalidCapture,
  onKeyDown,
  onKeyDownCapture,
  onKeyPress,
  onKeyPressCapture,
  onKeyUp,
  onKeyUpCapture,
  onLoad,
  onLoadCapture,
  onLoadedData,
  onLoadedDataCapture,
  onLoadedMetadata,
  onLoadedMetadataCapture,
  onLoadStart,
  onLoadStartCapture,
  onLostPointerCapture,
  onLostPointerCaptureCapture,
  onMouseDown,
  onMouseDownCapture,
  onMouseEnter,
  onMouseLeave,
  onMouseMove,
  onMouseMoveCapture,
  onMouseOut,
  onMouseOutCapture,
  onMouseOver,
  onMouseOverCapture,
  onMouseUp,
  onMouseUpCapture,
  onPaste,
  onPasteCapture,
  onPause,
  onPauseCapture,
  onPlay,
  onPlayCapture,
  onPlaying,
  onPlayingCapture,
  onPointerCancel,
  onPointerCancelCapture,
  onPointerDown,
  onPointerDownCapture,
  onPointerEnter,
  onPointerEnterCapture,
  onPointerLeave,
  onPointerLeaveCapture,
  onPointerMove,
  onPointerMoveCapture,
  onPointerOut,
  onPointerOutCapture,
  onPointerOver,
  onPointerOverCapture,
  onPointerUp,
  onPointerUpCapture,
  onProgress,
  onProgressCapture,
  onRateChange,
  onRateChangeCapture,
  onReset,
  onResetCapture,
  onScroll,
  onScrollCapture,
  onSeeked,
  onSeekedCapture,
  onSeeking,
  onSeekingCapture,
  onSelect,
  onSelectCapture,
  onStalled,
  onStalledCapture,
  onSubmit,
  onSubmitCapture,
  onSuspend,
  onSuspendCapture,
  onTimeUpdate,
  onTimeUpdateCapture,
  onTouchCancel,
  onTouchCancelCapture,
  onTouchEnd,
  onTouchEndCapture,
  onTouchMove,
  onTouchMoveCapture,
  onTouchStart,
  onTouchStartCapture,
  onTransitionEnd,
  onTransitionEndCapture,
  onVolumeChange,
  onVolumeChangeCapture,
  onWaiting,
  onWaitingCapture,
  onWheel,
  onWheelCapture,
};

// declaring this here so that it displays evenly spaced in storybook.
const activeBarDetailString = `<Bar dataKey="value" activeBar={false} />\n
<Bar dataKey="value" activeBar={{ stroke: 'red', strokeWidth: 2 }} />\n
<Bar dataKey="value" activeBar={<CustomizedBar />} />\n
<Bar dataKey="value" activeBar={renderBar} />`;

const StyleProps: Args = {
  strokeDasharray: GeneralStyle.strokeDasharray,
  stroke: GeneralStyle.stroke,
  fill: GeneralStyle.fill,
  strokeWidth: GeneralStyle.strokeWidth,
  hide,
  background: {
    description: `If false set, background of bars will not be drawn. If true set,
    background of bars will be drawn which have the props calculated internally.
    If object set, background of bars will be drawn which have the props mergered by the internal calculated props
     and the option. If ReactElement set, the option can be the custom background element.
      If set a function, the function will be called to render customized background.`,
    table: { category: 'Style' },
  },
  barSize: {
    table: { category: 'Style' },
  },
  radius: {
    table: { category: 'Style' },
  },
  maxBarSize: {
    table: { category: 'Style' },
  },
  legendType: {
    ...legendType,
    table: { category: 'Style' },
  },
  shape: {
    table: { category: 'Style' },
  },
  activeBar: {
    description: `The active bar is shown when a user enters a bar chart and this chart has tooltip.
    If set to false, no active bar will be drawn.
    If set to true, active bar will be drawn with the props calculated internally.
    If passed an object, active bar will be drawn,
    and the internally calculated props will be merged with the key value pairs of the passed object.
    If passed a ReactElement, the option can be the custom active bar element.
    If passed a function, the function will be called to render a customized active bar.`,
    table: {
      type: {
        summary: 'Boolean | Object | ReactElement | Function',
        detail: activeBarDetailString,
      },
      category: 'Tooltip',
    },
  },
  label: {
    description: `If set a string or a number, default label will be drawn, and the option is content.
    If set a React element, the option is the custom react element of drawing label. If set a function,
    the function will be called to render customized label.`,
    table: {
      type: {
        summary: 'string | number | ReactElement | Function',
      },
      category: 'Style',
    },
  },
  minPointSize: {
    table: {
      category: 'Style',
    },
    description: `The minimal height of a bar in a horizontal BarChart, or the minimal width of a bar
    in a vertical BarChart. By default, 0 values are not shown. To visualize a 0 (or close to zero) point,
    set the minimal point size to a pixel value like 3. In stacked bar charts,
    minPointSize might not be respected for tightly packed values.
      So we strongly recommend not using this props in stacked BarChart.
      You may provide a function to conditionally change this prop based on Bar value.`,
  },
};

const GeneralBarProps: Args = {
  ...GeneralProps,
  stackId: {
    table: { category: 'General' },
    description: `The stack id of bar, when two bars have the same stack id, then two bars are stacked in order.`,
  },
};

const AnimationPropsForBar: Args = {
  animationBegin,
  animationEasing,
  animationDuration,
  isAnimationActive,
};

export default {
  component: Bar,
  argTypes: {
    ...GeneralBarProps,
    ...StyleProps,
    ...EventHandlersForBar,
    ...AnimationPropsForBar,
    // Deprecated
    dangerouslySetInnerHTML: { table: { category: 'Deprecated' }, hide: true, disable: true },
  },
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <ComposedChart
          width={surfaceWidth}
          height={surfaceHeight}
          margin={{
            top: 20,
            right: 20,
            bottom: 20,
            left: 20,
          }}
          data={pageData}
        >
          {/* All components are added to show the interaction with the Bar properties */}
          <Bar fill="red" stackId="1" dataKey="pv" />
          <Legend />
          <XAxis dataKey="name" />
          <YAxis />
          {/* The target component */}
          <Bar dataKey="uv" {...args} />
          <Tooltip />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    // This API story should have explicit values for all props
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    ...getStoryArgsFromArgsTypesObject(AnimationProps),
    isAnimationActive: true,
    label: { fill: 'red', fontSize: 20 },
    activeBar: {
      strokeWidth: 4,
      stroke: 'blue',
      fill: 'red',
      radius: 10,
    },
    dataKey: 'uv',
    unit: ' Visitors',
    stackId: '1',
    stroke: 'red',
    fill: 'teal',
    background: true,
    strokeWidth: 2,
    radius: 10,
    minPointSize: 150,
    maxBarSize: 50,
    animationEasing: 'linear',
    animationBegin: 0,
    animationDuration: 1500,
  },
};

const dataWithSmallishValues = [
  {
    name: 'Page A',
    uv: 4000,
    pv: 2400,
    amt: 2400,
  },
  {
    name: 'Page B',
    uv: 3000,
    pv: 1398,
    amt: 2210,
  },
  {
    name: 'Page C',
    uv: 2000,
    pv: 8,
    amt: 2290,
  },
  {
    name: 'Page D',
    uv: 2780,
    pv: 3908,
    amt: 2000,
  },
  {
    name: 'Page E',
    uv: 18,
    pv: 4800,
    amt: 2181,
  },
  {
    name: 'Page F',
    uv: 2390,
    pv: 3800,
    amt: 2500,
  },
  {
    name: 'Page G',
    uv: 3490,
    pv: 4300,
    amt: 2100,
  },
];
export const WithMinHeight = {
  render: (args: Record<string, any>) => {
    const renderCustomizedLabel = (props: any) => {
      const { x, y, width, value } = props;
      const radius = 10;

      return (
        <g>
          <circle cx={x + width / 2} cy={y - radius} r={radius} fill="#8884d8" />
          <text x={x + width / 2} y={y - radius} fill="#fff" textAnchor="middle" dominantBaseline="middle">
            {value.split(' ')[1]}
          </text>
        </g>
      );
    };

    return (
      <ResponsiveContainer width="100%" height="100%">
        <BarChart
          width={500}
          height={300}
          margin={{
            top: 20,
            right: 30,
            left: 20,
            bottom: 5,
          }}
          data={dataWithSmallishValues}
        >
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="name" />
          <YAxis />
          <Legend />
          <Bar {...args}>
            <LabelList dataKey="name" content={renderCustomizedLabel} />
          </Bar>
          <Bar dataKey="uv" fill="#82ca9d" minPointSize={10} />
          <Tooltip />
        </BarChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    ...getStoryArgsFromArgsTypesObject(AnimationProps),
    dataKey: 'pv',
    fill: '#8884d8',
    minPointSize: 5,
  },
};



================================================
FILE: storybook/stories/API/cartesian/Brush.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Brush.stories';

# Brush

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component

The Brush can be used within a `<AreaChart />`, a `<BarChart />`, a `<LineChart />`, a `<ComposedChart />` or a `<ScatterChart />`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/cartesian/Brush.stories.tsx
================================================
import React from 'react';
import { fireEvent, within, expect } from '@storybook/test';
import { Args } from '@storybook/react';
import { pageData } from '../../data';
import {
  Brush,
  ResponsiveContainer,
  ComposedChart,
  Line,
  Area,
  Bar,
  Scatter,
  ScatterChart,
  Tooltip,
} from '../../../../src';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';

const GeneralProps: Args = {
  ariaLabel: {
    description: 'The ARIA label of the brush.',
    table: { type: { summary: 'string' }, category: 'General' },
  },
  dataKey: {
    description: 'The key of data displayed in Brush.',
    table: { type: { summary: 'string | number | Function' }, category: 'General' },
  },
  x: {
    description: 'The x-coordinate of brush.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  y: {
    description: 'The y-coordinate of brush.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  dy: {
    description: 'Indicates a shift along the y-axis on the position of the Brush and its content.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  width: {
    description: 'The width of brush.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  height: {
    description: 'The height of brush.',
    table: { type: { summary: 'number' }, category: 'General' },
    defaultValue: 40,
  },
  travellerWidth: {
    description: 'The width of each traveller.',
    table: { type: { summary: 'number' }, category: 'General' },
    defaultValue: 5,
  },
  gap: {
    description: `The data with gap of refreshing chart. If the option is not set,
    the chart will be refreshed every time.`,
    table: { type: { summary: 'number' }, category: 'General' },
    defaultValue: 1,
  },
  fill: {
    description: 'Fill color',
    table: { type: { summary: 'string' }, category: 'SVG properties' },
    defaultValue: '#ccc',
  },
  startIndex: {
    description: 'The default start index of brush. If the option is not set, the start index will be 0.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  endIndex: {
    description: `The default end index of brush. If the option is not set,
    the end index will be calculated by the length of data`,
    table: { type: { summary: 'number' }, category: 'General' },
  },
  tickFormatter: {
    description: 'The formatter function of ticks.',
    table: { type: { summary: 'Function' }, category: 'General' },
  },
  onChange: {
    description: 'The handler of changing the active scope of brush.',
    table: { type: { summary: 'Function' }, category: 'Event handlers' },
  },
  onDragEnd: {
    description: 'The handler of ending the brush drag.',
    table: { type: { summary: 'Function' }, category: 'Event handlers' },
  },
  alwaysShowText: {
    control: { type: 'boolean' },
    table: { type: { summary: 'boolean' }, category: 'General' },
    defaultValue: false,
  },
};

export default {
  component: Brush,
  argTypes: GeneralProps,
};

export const API = {
  render: (args: Record<string, any>) => (
    <ResponsiveContainer width="100%" height={400}>
      <ComposedChart data={pageData}>
        <Line dataKey="uv" />
        <Brush {...args} />
      </ComposedChart>
    </ResponsiveContainer>
  ),
  args: getStoryArgsFromArgsTypesObject(GeneralProps),
  play: async ({ canvasElement }: { canvasElement: HTMLElement }) => {
    const canvas = within(canvasElement);
    const slider = await canvas.findAllByRole('slider');
    const leftSlider = slider[0];
    expect(leftSlider).toBeTruthy();

    fireEvent.mouseDown(leftSlider);
    fireEvent.mouseMove(leftSlider, { clientX: 200 });
    fireEvent.mouseUp(leftSlider);
  },
};

export const PanoramaWithLine = {
  render: (args: Record<string, any>) => (
    <ResponsiveContainer width="100%" height={400}>
      <ComposedChart data={pageData}>
        <Line dataKey="uv" />
        <Tooltip />
        <Brush {...args}>
          <ComposedChart data={pageData}>
            <Line dataKey="uv" />
          </ComposedChart>
        </Brush>
      </ComposedChart>
    </ResponsiveContainer>
  ),
  args: getStoryArgsFromArgsTypesObject(GeneralProps),
};

export const PanoramaWithArea = {
  render: (args: Record<string, any>) => (
    <ResponsiveContainer width="100%" height={400}>
      <ComposedChart data={pageData}>
        <Area dataKey="uv" />

        <Brush {...args}>
          <ComposedChart data={pageData}>
            <Area dataKey="uv" />
          </ComposedChart>
        </Brush>
      </ComposedChart>
    </ResponsiveContainer>
  ),
  args: getStoryArgsFromArgsTypesObject(GeneralProps),
};

export const PanoramaWithBar = {
  render: (args: Record<string, any>) => (
    <ResponsiveContainer width="100%" height={400}>
      <ComposedChart data={pageData}>
        <Bar dataKey="uv" />

        <Brush {...args}>
          <ComposedChart data={pageData}>
            <Bar dataKey="uv" />
          </ComposedChart>
        </Brush>
      </ComposedChart>
    </ResponsiveContainer>
  ),
  args: getStoryArgsFromArgsTypesObject(GeneralProps),
};

export const PanoramaWithScatter = {
  render: (args: Record<string, any>) => (
    <ResponsiveContainer width="100%" height={400}>
      <ScatterChart data={pageData}>
        <Scatter dataKey="uv" />

        <Brush {...args}>
          <ScatterChart data={pageData}>
            <Scatter dataKey="uv" />
          </ScatterChart>
        </Brush>
      </ScatterChart>
    </ResponsiveContainer>
  ),
  args: getStoryArgsFromArgsTypesObject(GeneralProps),
};



================================================
FILE: storybook/stories/API/cartesian/CartesianAxis.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './CartesianAxis.stories';

# CartesianAxis

The Cartesian Axis is used for the XAxis and the YAxis.
In most use cases, users will not need to use this component directly.

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/cartesian/CartesianAxis.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { CartesianAxis, ResponsiveContainer, Surface } from '../../../../src';
import { ticks } from '../../data';

const GeneralProps: Args = {
  x: {
    description: 'The x-coordinate of axis.',
    table: {
      type: {
        summary: 'Number',
        defaultValue: 0,
      },
      category: 'General',
    },
  },
  y: {
    description: 'The y-coordinate of axis.',
    table: {
      type: {
        summary: 'Number',
        defaultValue: 0,
      },
      category: 'General',
    },
  },
  width: {
    description: 'The width of axis.',
    table: {
      type: {
        summary: 'Number',
        defaultValue: 0,
      },
      category: 'General',
    },
  },
  height: {
    description: 'The height of axis.',
    table: {
      type: {
        summary: 'Number',
        defaultValue: 0,
      },
      category: 'General',
    },
  },
  orientation: {
    description: 'The orientation of axis.',
    table: {
      type: {
        summary: 'top | bottom | left | right',
        defaultValue: 'bottom',
      },
      category: 'General',
    },
  },
  viewBox: {
    description: 'The box of viewing area.',
    table: {
      type: {
        summary: 'Object',
        defaultValue: { x: 0, y: 0, width: 0, height: 0 },
      },
      category: 'General',
    },
  },
  axisLine: {
    description:
      'If set false, no axis line will be drawn. If set a object, the option is the configuration of axis line.',
    table: {
      type: {
        summary: 'Boolean | Object',
        defaultValue: true,
      },
      category: 'General',
    },
  },
  tickLine: {
    description: `If set false, no axis tick lines will be drawn. If set a object,
      the option is the configuration of tick lines.`,
    table: {
      type: {
        summary: 'Boolean | Object',
        defaultValue: true,
      },
      category: 'General',
    },
  },
  minTickGap: {
    description: 'The minimum gap between two adjacent labels.',
    table: {
      type: {
        summary: 'Number',
        defaultValue: 5,
      },
      category: 'General',
    },
  },
  tickSize: {
    description: 'The length of tick line.',
    table: {
      type: {
        summary: 'Number',
        defaultValue: 6,
      },
      category: 'General',
    },
  },
  interval: {
    description: `If set 0, all the ticks will be shown. If set preserveStart", "preserveEnd" or "preserveStartEnd",
      the ticks which is to be shown or hidden will be calculated automatically.`,
    table: {
      type: {
        summary: '"preserveStart" | "preserveEnd" | "preserveStartEnd" | "equidistantPreserveStart" | Number',
        defaultValue: 'preserveEnd',
      },
      category: 'General',
    },
    options: ['preserveStart', 'preserveStartEnd', 'preserveEnd', 'equidistantPreserveStart', 0, 1, 2, 3, 4, 5],
    control: {
      type: 'select',
    },
  },
  tick: {
    description: `If set false, no ticks will be drawn. If set a object, the option is the configuration of ticks.
      If set a React element, the option is the custom react element of drawing ticks. If set a function,
      the function will be called to render customized tick.`,
    table: {
      type: {
        summary: 'Boolean | Object | ReactElement | Function',
        defaultValue: null,
      },
      category: 'General',
    },
  },
  label: {
    description: `If set a string or a number, default label will be drawn, and the option is content.
      If set a React element, the option is the custom react element of drawing label.
      If set a function, the function will be called to render customized label.`,
    table: {
      type: {
        summary: 'String | Number | ReactElement | Function',
        defaultValue: null,
      },
      category: 'General',
    },
  },
  mirror: {
    description:
      'If set true, flips ticks around the axis line, displaying the labels inside the chart instead of outside.',
    table: {
      type: {
        summary: 'Boolean',
        defaultValue: false,
      },
      category: 'General',
    },
  },
  tickMargin: {
    description: 'The margin between tick line and tick.',
    table: {
      type: {
        summary: 'Number',
      },
      category: 'General',
    },
  },
};

export default {
  component: CartesianAxis,
  argTypes: {
    ...GeneralProps,
  },
};

export const API = {
  render: (args: Record<string, any>) => {
    const [surfaceWidth, surfaceHeight] = [600, 300];
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <Surface
          width={surfaceWidth}
          height={surfaceHeight}
          viewBox={{
            x: 0,
            y: 0,
            width: surfaceWidth,
            height: surfaceHeight,
          }}
        >
          <CartesianAxis
            viewBox={{
              x: 0,
              y: 0,
              width: surfaceWidth,
              height: surfaceHeight,
            }}
            {...args}
          />
        </Surface>
      </ResponsiveContainer>
    );
  },
  args: {
    ticks,
    orientation: 'bottom',
    interval: 'preserveEnd',
    width: 500,
    height: 600,
  },
};



================================================
FILE: storybook/stories/API/cartesian/CartesianGrid.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './CartesianGrid.stories';

# CartesianGrid

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component

The CartesianGrid can be used within a `<AreaChart />`, a `<BarChart />`, a `<LineChart />`, a `<ComposedChart />` or a `<ScatterChart />`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/cartesian/CartesianGrid.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { CartesianGrid, ResponsiveContainer, ComposedChart, XAxis, YAxis } from '../../../../src';
import { pageData } from '../../data';

const GeneralProps: Args = {
  x: {
    description: 'The x-coordinate of grid.',
    table: {
      type: {
        summary: 'Number',
        defaultValue: 0,
      },
      category: 'General',
    },
  },
  y: {
    description: 'The y-coordinate of grid.',
    table: {
      type: {
        summary: 'Number',
        defaultValue: 0,
      },
      category: 'General',
    },
  },
  width: {
    description: 'The width of grid.',
    table: {
      type: {
        summary: 'Number',
        defaultValue: 0,
      },
      category: 'General',
    },
  },
  height: {
    description: 'The height of grid.',
    table: {
      type: {
        summary: 'Number',
        defaultValue: 0,
      },
      category: 'General',
    },
  },
  horizontal: {
    description: 'If set false, no horizontal grid lines will be drawn.',
    table: {
      type: {
        summary: 'Boolean',
        defaultValue: true,
      },
      category: 'General',
    },
  },
  vertical: {
    description: 'If set false, no vertical grid lines will be drawn.',
    table: {
      type: {
        summary: 'Boolean',
        defaultValue: true,
      },
      category: 'General',
    },
  },
  horizontalPoints: {
    description: 'The y-coordinates of all horizontal lines.',
    table: {
      type: {
        summary: 'Array',
        defaultValue: [],
      },
      category: 'General',
    },
  },
  verticalPoints: {
    description: 'The x-coordinates of all vertical lines.',
    table: {
      type: {
        summary: 'Array',
        defaultValue: [],
      },
      category: 'General',
    },
  },
  strokeDasharray: {
    description: 'The pattern of dashes and gaps used to paint the lines of the grid',
    table: {
      type: {
        summary: 'String',
        defaultValue: null,
      },
      category: 'General',
    },
  },
};

export default {
  component: CartesianGrid,
  argTypes: {
    ...GeneralProps,
  },
};

export const API = {
  render: (args: Record<string, any>) => {
    const [surfaceWidth, surfaceHeight] = [500, 500];
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <ComposedChart width={surfaceWidth} height={surfaceHeight}>
          <CartesianGrid {...args} />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    y: 0,
    x: 0,
    width: 500,
    height: 500,
    fillOpacity: 0.4,
    horizontalPoints: [10, 20, 30, 100, 400],
    verticalPoints: [100, 200, 300, 400],
    verticalFill: ['red', '#eee'],
    horizontalFill: ['#eee', 'yellow'],
    strokeDasharray: '10 10',
  },
};

export const MultipleGrids = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={500}>
        <ComposedChart width={500} height={500} data={pageData}>
          <XAxis dataKey="name" />
          <YAxis dataKey="pv" />
          {args.displayGridA && <CartesianGrid verticalFill={['#aaeeee', '#eeeeaa']} stroke="trasparent" />}
          {args.displayGridB && <CartesianGrid stroke="silver" strokeDasharray="3 3" strokeWidth={3} />}
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    displayGridA: true,
    displayGridB: true,
  },
};



================================================
FILE: storybook/stories/API/cartesian/ErrorBar.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './ErrorBar.stories';

# ErrorBar

ErrorBar requires Axis type property to be a  `number` to which direction it is used.

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component

The ErrorBar can be used within `<Bar />`, `<Line />` or `<Scatter />`.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />




================================================
FILE: storybook/stories/API/cartesian/ErrorBar.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { ScatterChart, ErrorBar, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Scatter } from '../../../../src';
import { errorData } from '../../data';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';

const GeneralProps: Args = {
  dataKey: {
    description: `The key of a group of error values in data. The error values can be a single value for
    symmetric error bars or an array of a lower and upper error value for asymmetric error bars.`,
    table: { type: { summary: 'string | number | Function' }, category: 'General' },
  },
};

const StyleProps: Args = {
  stroke: {
    description: 'The color of the error bars.',
    control: { type: 'color' },
    table: {
      type: {
        summary: 'string',
      },
      category: 'Style',
    },
    defaultValue: '#ccc',
  },
  width: {
    description: 'The width of the error bar ends.',
    table: {
      type: {
        summary: 'string | number',
      },
      category: 'Style',
      defaultValue: {
        summary: 5,
      },
    },
    defaultValue: 5,
  },
  strokeWidth: {
    description: 'The width of the lines used to make the error bars.',
    table: {
      type: {
        summary: 'string | number',
      },
      category: 'Style',
    },
    defaultValue: 1.5,
  },
  direction: {
    description: `Only used for ScatterChart with error bars in two directions.
    Only accepts a value of "x" or "y" and makes the error bars lie in that direction.`,
    table: {
      type: {
        summary: 'string',
      },
      category: 'Style',
    },
  },
};

export default {
  component: ErrorBar,
  argTypes: {
    ...GeneralProps,
    ...StyleProps,
  },
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={500}>
        <ScatterChart
          margin={{
            top: 5,
            right: 30,
            left: 20,
            bottom: 5,
          }}
          width={730}
          height={250}
        >
          <CartesianGrid />
          <XAxis dataKey="x" type="number" />
          <YAxis dataKey="y" type="number" />
          <Scatter data={errorData} fill="#ff7300">
            <ErrorBar dataKey="errorY" {...args} />
          </Scatter>
        </ScatterChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    ...getStoryArgsFromArgsTypesObject(StyleProps),
    width: 4,
    strokeWidth: 2,
    stroke: 'green',
    direction: 'y',
    dataKey: 'errorY',
  },
};



================================================
FILE: storybook/stories/API/cartesian/Funnel.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Funnel.stories';

# Funnel

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component

The Funnel component can be used within a `<FunnelChart />`.

## Child Component

The Funnel component can be used with the following child components: `<LabelList />` `<Cell />`.

## Properties

The following table shows a complete list of all properties of the component. Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/cartesian/Funnel.stories.tsx
================================================
import React from 'react';
import { nameKey, activeShape, General } from '../props/CartesianComponentShared';
import { legendType } from '../props/Legend';
import { AnimationProps } from '../props/AnimationProps';
import { Funnel, FunnelChart, LabelList, Legend, ResponsiveContainer } from '../../../../src';
import { ChartSizeProps } from '../props/ChartProps';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import {
  EventHandlers,
  onAnimationEnd,
  onAnimationStart,
  onClick,
  onMouseDown,
  onMouseEnter,
  onMouseLeave,
  onMouseMove,
  onMouseOut,
  onMouseOver,
  onMouseUp,
} from '../props/EventHandlers';
import { ResponsiveProps } from '../props/Tooltip';
import { GeneralStyle } from '../props/Styles';

export default {
  argTypes: {
    nameKey,
    legendType,
    shape: activeShape,
    activeShape,
    ...AnimationProps,
    ...General,
    ...GeneralStyle,
    ...ChartSizeProps,
    ...EventHandlers,
    ...ResponsiveProps,
    onAnimationStart,
    onAnimationEnd,
    onClick,
    onMouseDown,
    onMouseUp,
    onMouseMove,
    onMouseOver,
    onMouseOut,
    onMouseEnter,
    onMouseLeave,
  },
  component: Funnel,
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={200}>
        <FunnelChart layout="horizontal">
          <Funnel dataKey={args.dataKey} {...args}>
            <LabelList dataKey="name" fill="#000" position="right" stroke="none" />
            <Legend />
          </Funnel>
        </FunnelChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(AnimationProps),
    ...getStoryArgsFromArgsTypesObject(General),
    ...getStoryArgsFromArgsTypesObject(GeneralStyle),
    ...getStoryArgsFromArgsTypesObject(ChartSizeProps),
    width: 400,
    dataKey: 'value',
    stroke: '#424242',
    isAnimationActive: true,
    lastShapeType: 'rectangle',
    orientation: 'horizontal',
    data: [
      {
        fill: '#EEEEEE',
        name: 'A',
        value: 1009,
      },
      {
        fill: '#E0E0E0',
        name: 'B',
        value: 903,
      },
      {
        fill: '#BDBDBD',
        name: 'C',
        value: 756,
      },
      {
        fill: '#9E9E9E',
        name: 'D',
        value: 622,
      },
      {
        fill: '#757575',
        name: 'E',
        value: 602,
      },
      {
        fill: '#424242',
        name: 'F',
        value: 580,
      },
    ],
  },
};



================================================
FILE: storybook/stories/API/cartesian/Line.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Line.stories';

# Line

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component
The Line can be used within a `<ComposedChart/>` or a `<LineChart/>`.

## Child component
The Line can be used with the following child components: `<ErrorBar/>` `<LabelList/>`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />








================================================
FILE: storybook/stories/API/cartesian/Line.stories.tsx
================================================
import React from 'react';
import { Line, ResponsiveContainer, ComposedChart, Legend, Tooltip, XAxis, YAxis } from '../../../../src';
import { pageData } from '../../data';
import { EventHandlers } from '../props/EventHandlers';
import { animateNewValues, AnimationProps } from '../props/AnimationProps';
import { legendType } from '../props/Legend';
import { LineStyle } from '../props/Styles';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { data, General as GeneralProps } from '../props/CartesianComponentShared';
import { ResponsiveProps } from '../props/Tooltip';

export default {
  argTypes: {
    ...EventHandlers,
    animateNewValues,
    ...AnimationProps,
    legendType,
    ...GeneralProps,
    data,
    ...ResponsiveProps,
    ...LineStyle,
    // Deprecated
    dangerouslySetInnerHTML: { table: { category: 'Deprecated' }, hide: true, disable: true },
  },
  component: Line,
};

export const API = {
  render: (args: Record<string, any>) => {
    const [surfaceWidth, surfaceHeight] = [600, 300];
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <ComposedChart
          width={surfaceWidth}
          height={surfaceHeight}
          margin={{
            top: 20,
            right: 20,
            bottom: 20,
            left: 20,
          }}
          data={pageData}
        >
          {/* All components are added to show the interaction with the Area properties */}
          <Legend />
          <XAxis dataKey="name" />
          <YAxis />
          {/* The target component */}
          <Line dataKey="uv" {...args} />
          <Tooltip />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    // This API story should have explicit values for all props
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    ...getStoryArgsFromArgsTypesObject(LineStyle),
    ...getStoryArgsFromArgsTypesObject(ResponsiveProps),
    ...getStoryArgsFromArgsTypesObject(AnimationProps),
    type: 'linear',
    connectNulls: true,
    stroke: 'red',
    fill: 'teal',
    strokeDasharray: '4 1',
    label: { fill: 'red', fontSize: 20 },
    dot: { stroke: 'green', strokeWidth: 2 },
    isAnimationActive: true,
    activeDot: { stroke: 'green', strokeWidth: 2 },
    tooltipType: 'responsive',
    dataKey: 'uv',
    unit: ' Visitors',
  },
};



================================================
FILE: storybook/stories/API/cartesian/ReferenceArea.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './ReferenceArea.stories';

# ReferenceArea

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component
The ReferenceArea can be used within the following parent components:

`<AreaChart/>` `<BarChart/>` `<LineChart/>` `<ComposedChart/>` `<ScatterChart/>`

## Child component
The ReferenceArea can be used with the following child components: `<Label/>`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/cartesian/ReferenceArea.stories.tsx
================================================
import { Args } from '@storybook/react';
import React from 'react';
import { Line, ComposedChart, ReferenceArea, CartesianGrid, XAxis, YAxis, ResponsiveContainer } from '../../../../src';
import { pageData } from '../../data';
import { isUpdateAnimationActive, radius } from '../props/RectangleProps';
import {
  onClick,
  onMouseDown,
  onMouseEnter,
  onMouseLeave,
  onMouseMove,
  onMouseOut,
  onMouseOver,
  onMouseUp,
} from '../props/EventHandlers';
import { animationBegin, animationDuration, animationEasing, isAnimationActive } from '../props/AnimationProps';
import { GeneralStyle } from '../props/Styles';
import { ReferenceComponentGeneralArgs, ReferenceComponentStyle } from '../props/ReferenceComponentShared';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';

const StyleProps: Args = {
  ...GeneralStyle,
  ...ReferenceComponentStyle,
  label: {
    description: `If set a string or a number, default label will be drawn, and the option is content.
    If set a React element, the option is the custom react element of drawing label. If set a function,
    the function will be called to render customized label.`,
    table: {
      type: {
        summary: 'String | Number | ReactElement | Function',
        detail:
          '<ReferenceArea x1="01" x2="08" label="MAX"/>\n' +
          '<ReferenceArea y1={100} y2={500} label={<CustomizedLabel />}/>',
      },
      category: 'Style',
    },
  },
  shape: {
    description: `Renders a svg returned by the react element or function.
    If undefined, it will default to rectangle controlled by other props, like \`radius\` and \`strokeWidth\`.`,
    table: {
      type: {
        summary: 'ReactElement | Function | undefined',
        detail: '<ReferenceArea shape={<CustomSvgShape/>}/>',
      },
      category: 'Style',
    },
  },
};

const GeneralProps: Args = {
  ...ReferenceComponentGeneralArgs,
  x1: {
    description: `A boundary value of the area. If the specified x-axis is a number axis, the type of x
      must be Number. If the specified x-axis is a category axis, the value of x must be one of the
      categories. If x1 is not set, the first value on the x-axis is used instead. If one of x1 or x2
      is invalid, the area will not be drawn.`,
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
  x2: {
    description: `A boundary value of the area. If the specified x-axis is a number axis, the type of x
    must be Number. If the specified x-axis is a category axis, the value of x must be one of the
    categories. If x2 is not set, the last value on the x-axis is used instead. If one of x1 or x2 is
    invalid, the area will not be drawn.`,
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
  y1: {
    description: `A boundary value of the area. If the specified y-axis is a number axis, the type of y
    must be Number. If the specified y-axis is a category axis, the value of y must be one of the
    categories. If y1 is not set, the first value on the y-axis is used instead. If one of y1 or y2 is
    invalid, the area will not be drawn.`,
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
  y2: {
    description: `A boundary value of the area. If the specified y-axis is a number axis, the type of y
    must be Number. If the specified y-axis is a category axis, the value of y must be one of the
    categories. If y2 is not set, the last value on the y-axis is used instead. If one of y1 or y2 is
    invalid, the area will not be drawn.`,
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
};

const referenceAreaArgTypes = {
  ...StyleProps,
  ...GeneralProps,
  // Rectangle
  radius,
  // Event handlers
  onClick,
  onMouseDown,
  onMouseUp,
  onMouseMove,
  onMouseOver,
  onMouseOut,
  onMouseEnter,
  onMouseLeave,
  // Animation
  animationBegin,
  animationDuration,
  animationEasing,
  isAnimationActive,
  isUpdateAnimationActive,
};

export default {
  argTypes: referenceAreaArgTypes,
  component: ReferenceArea,
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={500}>
        <ComposedChart
          data={pageData}
          margin={{
            top: 5,
            right: 30,
            left: 20,
            bottom: 5,
          }}
        >
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="name" />
          <YAxis type="number" />
          <Line dataKey="uv" />
          <ReferenceArea {...args} />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(referenceAreaArgTypes),
    x1: 'Page B',
    x2: 'Page E',
    y1: 1000,
    y2: 1500,
    stroke: 'red',
    strokeOpacity: 0.3,
  },
};



================================================
FILE: storybook/stories/API/cartesian/ReferenceDot.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './ReferenceDot.stories';

# ReferenceDot

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component

The ReferenceDot can be used within `<AreaChart />`, `<BarChart />`, `<LineChart />`, `<ComposedChart />` or `<ScatterChart />`.

## Child component

The ReferenceDot can be used with the following child components: `<Label />`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />




================================================
FILE: storybook/stories/API/cartesian/ReferenceDot.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { Bar, ComposedChart, ReferenceDot, CartesianGrid, XAxis, YAxis, ResponsiveContainer } from '../../../../src';
import { pageData } from '../../data';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { EventHandlers } from '../props/EventHandlers';
import { r } from '../props/DotProps';
import { GeneralStyle } from '../props/Styles';
import {
  ReferenceComponentGeneralArgs,
  ReferenceComponentInternalArgs,
  ReferenceComponentStyle,
} from '../props/ReferenceComponentShared';

const GeneralProps: Args = {
  ...ReferenceComponentGeneralArgs,
  x: {
    description: `If the x-axis specified by xAxisId is a number axis, the type of x must be Number.
      If the x-axis specified by xAxisId is a category axis, the value of x must be one of
      the categories, otherwise no dot will be drawn.`,
    table: { type: { summary: 'number | string' }, category: 'General' },
  },
  y: {
    description: `If the y-axis specified by yAxisId is a number axis, the type of y must be Number.
      If the y-axis specified by yAxisId is a category axis, the value of y must be one of
      the categories, otherwise no dot will be drawn.`,
    table: { type: { summary: 'number | string' }, category: 'General' },
  },
};

const LabelProps: Args = {
  label: {
    description: `If set a string or a number, default label will be drawn, and the option is content.
    If set a React element, the option is the custom react element of drawing label. If set a function,
    the function will be called to render customized label.`,
    table: {
      type: {
        summary: 'string | number | ReactElement | Function',
        detail:
          '<ReferenceDot x="a" y={400} label="MAX"/>\n' +
          '<ReferenceDot x="a" y={400} label={<CustomizedLabel />}/>\n' +
          '<ReferenceDot x="a" y={400} label={renderLabel} />',
      },
      category: 'Label',
    },
  },
};

const StyleProps: Args = {
  ...GeneralStyle,
  ...ReferenceComponentStyle,
  shape: {
    description: `If set a ReactElement, the shape of the dot can be customized. If set a function,
    the function will be called to render a customized shape.`,
    table: {
      type: {
        summary: 'ReactElement | Function',
      },
      category: 'Style',
    },
  },
};

export default {
  argTypes: {
    ...StyleProps,
    ...GeneralProps,
    ...LabelProps,
    ...ReferenceComponentInternalArgs,
    ...EventHandlers,
    // Dot
    r,
    // Deprecated
    dangerouslySetInnerHTML: { table: { category: 'Deprecated' }, hide: true, disable: true },
  },
  component: ReferenceDot,
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={500}>
        <ComposedChart
          data={pageData}
          margin={{
            top: 5,
            right: 30,
            left: 20,
            bottom: 5,
          }}
        >
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="name" />
          <YAxis type="number" />
          <Bar type="monotone" dataKey="uv" />
          <ReferenceDot {...args} />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    ...getStoryArgsFromArgsTypesObject(StyleProps),
    x: 'Page E',
    y: 1520,
    r: 20,
    stroke: 'red',
    fill: 'teal',
    label: { fill: 'red', fontSize: 20 },
  },
};



================================================
FILE: storybook/stories/API/cartesian/ReferenceLine.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './ReferenceLine.stories';

# ReferenceLine

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>


## Parent Component

The ReferenceLine can be used within `<AreaChart />`, `<BarChart />`, `<LineChart />`, `<ComposedChart />` or `<ScatterChart />`.

## Child component

The ReferenceLine can be used with the following child components: `<Label />`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />




================================================
FILE: storybook/stories/API/cartesian/ReferenceLine.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { ComposedChart, Line, ReferenceLine, CartesianGrid, XAxis, YAxis, ResponsiveContainer } from '../../../../src';
import { pageData } from '../../data';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { GeneralStyle } from '../props/Styles';
import {
  ReferenceComponentGeneralArgs,
  ReferenceComponentInternalArgs,
  ReferenceComponentStyle,
} from '../props/ReferenceComponentShared';

const GeneralProps: Args = {
  ...ReferenceComponentGeneralArgs,
  x: {
    description: `If set a string or a number, a vertical line perpendicular to the x-axis specified by xAxisId
    will be drawn. If the specified x-axis is a number axis, the type of x must be Number. If the specified x-axis
    is a category axis, the value of x must be one of the categories, otherwise no line will be drawn.`,
    table: { type: { summary: 'number | string' }, category: 'General' },
  },
  y: {
    description: `If set a string or a number, a horizontal line perpendicular to the y-axis specified by yAxisId
    will be drawn. If the specified y-axis is a number axis, the type of y must be Number. If the specified y-axis
    is a category axis, the value of y must be one of the categories, otherwise no line will be drawn.`,
    table: { type: { summary: 'number | string' }, category: 'General' },
  },
  segment: {
    description: 'Array of endpoints in { x, y } format. These endpoints would be used to draw the line.',
    table: { type: { summary: 'array' }, category: 'General' },
  },
};

const LabelProps: Args = {
  label: {
    description: `If set a string or a number, default label will be drawn, and the option is content.
    If set a React element, the option is the custom react element of drawing label. If set a function,
    the function will be called to render customized label.`,
    table: {
      type: {
        summary: 'string | number | ReactElement | Function',
        detail:
          '<ReferenceLine x="05" label="Middle" />\n' +
          '<ReferenceLine y={400} yAxisId="left" label={<CustomizedLabel />} />',
      },
      category: 'Label',
    },
  },
};

const StyleProps: Args = {
  ...ReferenceComponentStyle,
  stroke: {
    ...GeneralStyle.stroke,
    defaultValue: '#ccc',
  },
  strokeWidth: GeneralStyle.strokeWidth,
  strokeDasharray: GeneralStyle.strokeDasharray,
  position: {
    description:
      "Defines at which position of an axis point the line will start/end if the axis does not have type 'number'.",
    table: { type: { summary: "'start' | 'middle' | 'end'" }, category: 'Style' },
  },
  shape: {
    description: `If set a ReactElement, the shape of the line can be customized. If set a function,
    the function will be called to render a customized shape.`,
    table: {
      type: {
        summary: 'ReactElement | Function',
      },
      category: 'Style',
    },
  },
};

const InternalProps: Args = {
  ...ReferenceComponentInternalArgs,
  viewBox: {
    description: 'The box of the viewing area, usually calculated internally.',
    table: { type: { summary: '{x: number, y: number, width: number, height: number}' }, category: 'Internal' },
  },
};

export default {
  argTypes: {
    ...GeneralProps,
    ...LabelProps,
    ...StyleProps,
    ...ReferenceComponentInternalArgs,
    ...InternalProps,
    // Deprecated
    dangerouslySetInnerHTML: { table: { category: 'Deprecated' }, hide: true, disable: true },
  },
  component: ReferenceLine,
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={500}>
        <ComposedChart
          data={pageData}
          margin={{
            top: 5,
            right: 30,
            left: 20,
            bottom: 5,
          }}
        >
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="name" />
          <YAxis type="number" />
          <ReferenceLine {...args} />
          <Line dataKey="uv" />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    ...getStoryArgsFromArgsTypesObject(StyleProps),
    y: 1520,
    stroke: 'blue',
    strokeWidth: 2,
    strokeDasharray: '4 1',
    label: 'My example label',
  },
};



================================================
FILE: storybook/stories/API/cartesian/Scatter.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Scatter.stories';

# Scatter
The Scatter component is different to all other cartesian components in that it does not require a dataKey to be set.
Without a dataKey, the xAxis and yAxis are used to determine the position of the scatter points, which both require a dataKey.

If the dataKey is set, and no xAxis or yAxis is set, the Scatter will use the dataKey to determine the y-Axis value of the scatter points, and the index of each data point on the xAxis.

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>


## Parent Component

The Scatter can be used within a `<ScatterChart/>` or a `<ComposedChart/>`.

## Child component

The Scatter can be used with the following child components: `<Cell />`, `<LabelList/>` or a `<ErrorBar/>`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />




================================================
FILE: storybook/stories/API/cartesian/Scatter.stories.tsx
================================================
import React from 'react';
import { ComposedChart, Scatter, XAxis, YAxis, ResponsiveContainer } from '../../../../src';
import { pageData } from '../../data';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { data as dataProp, dataKey as dataKeyProp, xAxisId, yAxisId, zAxisId } from '../props/CartesianComponentShared';
import {
  onAbort,
  onAbortCapture,
  onAnimationEnd,
  onAnimationEndCapture,
  onAnimationIteration,
  onAnimationIterationCapture,
  onAnimationStart,
  onAnimationStartCapture,
  onAuxClick,
  onAuxClickCapture,
  onBeforeInput,
  onBeforeInputCapture,
  onBlur,
  onBlurCapture,
  onCanPlay,
  onCanPlayCapture,
  onCanPlayThrough,
  onCanPlayThroughCapture,
  onChange,
  onChangeCapture,
  onClick,
  onClickCapture,
  onCompositionEnd,
  onCompositionEndCapture,
  onCompositionStart,
  onCompositionStartCapture,
  onCompositionUpdate,
  onCompositionUpdateCapture,
  onContextMenu,
  onContextMenuCapture,
  onCopy,
  onCopyCapture,
  onCut,
  onCutCapture,
  onDoubleClick,
  onDoubleClickCapture,
  onDrag,
  onDragCapture,
  onDragEnd,
  onDragEndCapture,
  onDragEnter,
  onDragEnterCapture,
  onDragExit,
  onDragExitCapture,
  onDragLeave,
  onDragLeaveCapture,
  onDragOver,
  onDragOverCapture,
  onDragStart,
  onDragStartCapture,
  onDrop,
  onDropCapture,
  onDurationChange,
  onDurationChangeCapture,
  onEmptied,
  onEmptiedCapture,
  onEncrypted,
  onEncryptedCapture,
  onEnded,
  onEndedCapture,
  onError,
  onErrorCapture,
  onFocus,
  onFocusCapture,
  onGotPointerCapture,
  onGotPointerCaptureCapture,
  onInput,
  onInputCapture,
  onInvalid,
  onInvalidCapture,
  onKeyDown,
  onKeyDownCapture,
  onKeyPress,
  onKeyPressCapture,
  onKeyUp,
  onKeyUpCapture,
  onLoad,
  onLoadCapture,
  onLoadedData,
  onLoadedDataCapture,
  onLoadedMetadata,
  onLoadedMetadataCapture,
  onLoadStart,
  onLoadStartCapture,
  onLostPointerCapture,
  onLostPointerCaptureCapture,
  onMouseDown,
  onMouseDownCapture,
  onMouseEnter,
  onMouseLeave,
  onMouseMove,
  onMouseMoveCapture,
  onMouseOut,
  onMouseOutCapture,
  onMouseOver,
  onMouseOverCapture,
  onMouseUp,
  onMouseUpCapture,
  onPaste,
  onPasteCapture,
  onPause,
  onPauseCapture,
  onPlay,
  onPlayCapture,
  onPlaying,
  onPlayingCapture,
  onPointerCancel,
  onPointerCancelCapture,
  onPointerDown,
  onPointerDownCapture,
  onPointerEnter,
  onPointerEnterCapture,
  onPointerLeave,
  onPointerLeaveCapture,
  onPointerMove,
  onPointerMoveCapture,
  onPointerOut,
  onPointerOutCapture,
  onPointerOver,
  onPointerOverCapture,
  onPointerUp,
  onPointerUpCapture,
  onProgress,
  onProgressCapture,
  onRateChange,
  onRateChangeCapture,
  onReset,
  onResetCapture,
  onScroll,
  onScrollCapture,
  onSeeked,
  onSeekedCapture,
  onSeeking,
  onSeekingCapture,
  onSelect,
  onSelectCapture,
  onStalled,
  onStalledCapture,
  onSubmit,
  onSubmitCapture,
  onSuspend,
  onSuspendCapture,
  onTimeUpdate,
  onTimeUpdateCapture,
  onTouchCancel,
  onTouchCancelCapture,
  onTouchEnd,
  onTouchEndCapture,
  onTouchMove,
  onTouchMoveCapture,
  onTouchStart,
  onTouchStartCapture,
  onTransitionEnd,
  onTransitionEndCapture,
  onVolumeChange,
  onVolumeChangeCapture,
  onWaiting,
  onWaitingCapture,
  onWheel,
  onWheelCapture,
} from '../props/EventHandlers';
import { animationBegin, animationDuration, animationEasing, isAnimationActive } from '../props/AnimationProps';
import { hide } from '../props/Styles';
import { legendType } from '../props/Legend';
import { StorybookArgs } from '../../../StorybookArgs';

const EventHandlers = {
  onAbort,
  onAbortCapture,
  onAnimationEnd,
  onAnimationEndCapture,
  onAnimationIteration,
  onAnimationIterationCapture,
  onAnimationStart,
  onAnimationStartCapture,
  onAuxClick,
  onAuxClickCapture,
  onBeforeInput,
  onBeforeInputCapture,
  onBlur,
  onBlurCapture,
  onCanPlay,
  onCanPlayCapture,
  onCanPlayThrough,
  onCanPlayThroughCapture,
  onChange,
  onChangeCapture,
  onClick,
  onClickCapture,
  onCompositionEnd,
  onCompositionEndCapture,
  onCompositionStart,
  onCompositionStartCapture,
  onCompositionUpdate,
  onCompositionUpdateCapture,
  onContextMenu,
  onContextMenuCapture,
  onCopy,
  onCopyCapture,
  onCut,
  onCutCapture,
  onDoubleClick,
  onDoubleClickCapture,
  onDrag,
  onDragCapture,
  onDragEnd,
  onDragEndCapture,
  onDragEnter,
  onDragEnterCapture,
  onDragExit,
  onDragExitCapture,
  onDragLeave,
  onDragLeaveCapture,
  onDragOver,
  onDragOverCapture,
  onDragStart,
  onDragStartCapture,
  onDrop,
  onDropCapture,
  onDurationChange,
  onDurationChangeCapture,
  onEmptied,
  onEmptiedCapture,
  onEncrypted,
  onEncryptedCapture,
  onEnded,
  onEndedCapture,
  onError,
  onErrorCapture,
  onFocus,
  onFocusCapture,
  onGotPointerCapture,
  onGotPointerCaptureCapture,
  onInput,
  onInputCapture,
  onInvalid,
  onInvalidCapture,
  onKeyDown,
  onKeyDownCapture,
  onKeyPress,
  onKeyPressCapture,
  onKeyUp,
  onKeyUpCapture,
  onLoad,
  onLoadCapture,
  onLoadedData,
  onLoadedDataCapture,
  onLoadedMetadata,
  onLoadedMetadataCapture,
  onLoadStart,
  onLoadStartCapture,
  onLostPointerCapture,
  onLostPointerCaptureCapture,
  onMouseDown,
  onMouseDownCapture,
  onMouseEnter,
  onMouseLeave,
  onMouseMove,
  onMouseMoveCapture,
  onMouseOut,
  onMouseOutCapture,
  onMouseOver,
  onMouseOverCapture,
  onMouseUp,
  onMouseUpCapture,
  onPaste,
  onPasteCapture,
  onPause,
  onPauseCapture,
  onPlay,
  onPlayCapture,
  onPlaying,
  onPlayingCapture,
  onPointerCancel,
  onPointerCancelCapture,
  onPointerDown,
  onPointerDownCapture,
  onPointerEnter,
  onPointerEnterCapture,
  onPointerLeave,
  onPointerLeaveCapture,
  onPointerMove,
  onPointerMoveCapture,
  onPointerOut,
  onPointerOutCapture,
  onPointerOver,
  onPointerOverCapture,
  onPointerUp,
  onPointerUpCapture,
  onProgress,
  onProgressCapture,
  onRateChange,
  onRateChangeCapture,
  onReset,
  onResetCapture,
  onScroll,
  onScrollCapture,
  onSeeked,
  onSeekedCapture,
  onSeeking,
  onSeekingCapture,
  onSelect,
  onSelectCapture,
  onStalled,
  onStalledCapture,
  onSubmit,
  onSubmitCapture,
  onSuspend,
  onSuspendCapture,
  onTimeUpdate,
  onTimeUpdateCapture,
  onTouchCancel,
  onTouchCancelCapture,
  onTouchEnd,
  onTouchEndCapture,
  onTouchMove,
  onTouchMoveCapture,
  onTouchStart,
  onTouchStartCapture,
  onTransitionEnd,
  onTransitionEndCapture,
  onVolumeChange,
  onVolumeChangeCapture,
  onWaiting,
  onWaitingCapture,
  onWheel,
  onWheelCapture,
};

const AnimationProps = {
  animationBegin,
  animationDuration,
  animationEasing,
  isAnimationActive,
};

const StyleProps: StorybookArgs = {
  hide,
  legendType,
  line: {
    description: `If false set, line will not be drawn. If true set, line will be drawn which have
    the props calculated internally. If object set, line will be drawn which have the props mergered
    by the internal calculated props and the option. If ReactElement set, the option can be the custom
    line element. If set a function, the function will be called to render Customized line.`,
    table: {
      type: {
        summary: 'Boolean | Object | ReactElement | Function',
      },
      category: 'Style',
      defaultValue: false,
    },
  },
  lineJointType: {
    options: [
      'basis',
      'basisClosed',
      'basisOpen',
      'bumpX',
      'bumpY',
      'bump',
      'linear',
      'linearClosed',
      'natural',
      'monotoneX',
      'monotoneY',
      'monotone',
      'step',
      'stepBefore',
      'stepAfter',
    ],
    table: {
      type: {
        summary: `basis
        | basisClosed
        | basisOpen
        | linear
        | linearClosed
        | natural
        | monotoneX
        | monotoneY
        | monotone
        | step
        | stepBefore
        | stepAfter
        | CurveFactory`,
      },
      category: 'Style',
      defaultValue: 'linear',
    },
  },
  lineType: {
    description: `If 'joint' set, line will generated by just jointing all the points.
      If 'fitting' set, line will be generated by fitting algorithm.`,
    table: {
      type: {
        summary: 'joint | fitting',
      },
      category: 'Style',
      defaultValue: 'joint',
    },
  },
  label: {
    description: `If set a string or a number, default label will be drawn, and the option is content.
    If set a React element, the option is the custom react element of drawing label. If set a function,
    the function will be called to render customized label.`,
    table: {
      type: {
        summary: 'string | number | ReactElement | Function',
      },
      category: 'Style',
    },
  },
  shape: {
    description: `If a string set, specified symbol will be used to show scatter item.
    If ReactElement set, the option can be the custom scatter item element.
    If set a function, the function will be called to render customized scatter item.`,
    options: ['circle', 'cross', 'diamond', 'square', 'star', 'triangle', 'wye'],
    table: {
      type: {
        summary: 'circle | cross | diamond | square | star | triangle | wye | ReactElement | Function',
      },
      category: 'Style',
      defaultValue: 'circle',
    },
  },
};

const ReactiveProps = {
  activeShape: {
    description: `The active shape is shown when a user enters a scatter chart and this chart has tooltip.
      If set to false, no active shape will be drawn. If set to true, active shape will be drawn with the
      props calculated internally. If passed an object, active shape will be drawn, and the internally
      calculated props will be merged with the key value pairs of the passed object. If passed a ReactElement,
      the option can be the custom active shape element. If passed a function, the function will be called to
      render a customized active shape.`,
    table: {
      type: {
        summary: 'Boolean | Object | ReactElement | Function',
        detail: `'<Scatter activeShape={false} />\n' +
      '<Scatter activeShape={{ stroke: 'red', strokeWidth: 2 }} />\n' +
      '<Scatter activeShape={<CustomizedDot />} />\n' +
      '<Scatter activeShape={renderDot} />'`,
      },
      defaultValue: true,
      category: 'Responsive',
    },
  },
  tooltipType: {
    table: {
      category: 'Responsive',
    },
  },
};

const [surfaceWidth, surfaceHeight] = [600, 300];

const GeneralPropsForScatter = {
  dataKey: dataKeyProp,
  data: dataProp,
  xAxisId,
  yAxisId,
  zAxisId,
};

export default {
  component: Scatter,
  argTypes: {
    ...GeneralPropsForScatter,
    ...StyleProps,
    ...EventHandlers,
    ...AnimationProps,
    ...ReactiveProps,
  },
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <ComposedChart
          width={surfaceWidth}
          height={surfaceHeight}
          margin={{
            top: 20,
            right: 20,
            bottom: 20,
            left: 20,
          }}
          data={pageData}
        >
          <Scatter {...args} />
          <XAxis dataKey="pv" />
          <YAxis dataKey="uv" />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(GeneralPropsForScatter),
    ...getStoryArgsFromArgsTypesObject(StyleProps),
    ...getStoryArgsFromArgsTypesObject(AnimationProps),
    shape: 'square',
    line: { stroke: 'red', strokeWidth: 2 },
    lineJointType: 'monotoneX',
    lineType: 'fitting',
  },
};



================================================
FILE: storybook/stories/API/cartesian/XAxis.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './XAxis.stories';

# XAxis

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component

The XAxis can be used within `<AreaChart />`, `<BarChart />`, `<LineChart />`, `<ComposedChart />` or `<ScatterChart />`.

## Child component

The XAxis can be used with the following child components: `<Label />`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/cartesian/XAxis.stories.tsx
================================================
import React from 'react';
import { CartesianGrid, Legend, Line, LineChart, ResponsiveContainer, Tooltip, XAxis, YAxis } from '../../../../src';
import { coordinateWithValueData } from '../../data';
import { XAxisProps } from '../props/XAxisProps';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';

export default {
  component: XAxis,
  argTypes: XAxisProps,
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={500}>
        <LineChart width={600} height={300} data={coordinateWithValueData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis {...args} />
          <YAxis />
          <Legend />
          <Line dataKey="y" />
          <Tooltip />
        </LineChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(XAxisProps),
    dataKey: 'x',
    domain: [100, 500],
    type: 'number',
    allowDataOverflow: true,
    tickMargin: 20,
    angle: 45,
    height: 70,
    label: { value: 'The Axis Label', position: 'insideBottomRight' },
  },
};



================================================
FILE: storybook/stories/API/cartesian/YAxis.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './YAxis.stories';

# YAxis

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>


## Parent Component

The YAxis can be used within `<AreaChart />`, `<BarChart />`, `<LineChart />`, `<ComposedChart />` or `<ScatterChart />`.

## Child component

The YAxis can be used with the following child components: `<Label />`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/cartesian/YAxis.stories.tsx
================================================
import React from 'react';
import { YAxis, XAxis, Line, ResponsiveContainer, LineChart, CartesianGrid, Tooltip, Legend } from '../../../../src';
import { coordinateWithValueData } from '../../data';
import { YAxisProps } from '../props/YAxisProps';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';

export default {
  component: YAxis,
  argTypes: YAxisProps,
};

const getWidth = (width: string | number) => {
  if (width === 'auto' || typeof width === 'number') {
    return width;
  }

  const num = parseInt(width, 10);
  return Number.isNaN(num) ? 120 : num;
};

export const API = {
  render: (args: Record<string, any>) => {
    const width = getWidth(args.width);

    return (
      <ResponsiveContainer width="100%" height={500}>
        <LineChart width={600} height={300} data={coordinateWithValueData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis />
          <YAxis {...args} width={width} />
          <Legend />
          <Line dataKey="y" />
          <Tooltip />
        </LineChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(YAxisProps),
    dataKey: 'pv',
    domain: [0, 300],
    type: 'number',
    allowDataOverflow: true,
    tickMargin: 20,
    angle: 45,
    width: '120',
    label: { value: 'The Axis Label', position: 'center', angle: 90 },
  },
};



================================================
FILE: storybook/stories/API/cartesian/ZAxis.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './ZAxis.stories';

# ZAxis

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>


## Parent Component

The ZAxis can be used within `<ScatterChart />`.
While not shown, it influences the size of the scatter points.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/cartesian/ZAxis.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import {
  ScatterChart,
  Scatter,
  ZAxis,
  CartesianGrid,
  XAxis,
  YAxis,
  ResponsiveContainer,
  Tooltip,
} from '../../../../src';
import { pageData } from '../../data';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { SCALE_TYPES } from '../../../../src/util/ReactUtils';

const GeneralProps: Args = {
  zAxisId: {
    description: 'The id of z-axis which is corresponding to the data.',
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
  unit: {
    description: 'The unit of data displayed in the axis.',
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
  range: {
    description: 'The range of axis.',
    table: { type: { summary: 'number[]' }, category: 'General' },
  },
  scale: {
    description: 'If "auto" set, the scale function is decided by the type of chart, and the props type.',
    options: SCALE_TYPES,
    default: 'auto',
    control: {
      type: 'select',
    },
    table: { type: { summary: 'ScaleType | Function' }, category: 'General' },
  },
  domain: {
    description: 'The domain of scale in this axis.',
    table: { type: { summary: 'AxisDomain' }, category: 'General' },
  },
};

export default {
  argTypes: {
    ...GeneralProps,
  },
  component: ZAxis,
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={500}>
        <ScatterChart width={400} height={400} margin={{ top: 20, right: 20, bottom: 0, left: 20 }}>
          <XAxis type="number" dataKey="uv" />
          <YAxis type="number" dataKey="amt" />
          <ZAxis {...args} />
          <CartesianGrid />
          <Scatter name="pageData" data={pageData} />
          <Tooltip />
        </ScatterChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    unit: 'km',
    name: 'A name',
    dataKey: 'pv',
    range: [0, 2000],
    type: 'number',
    scale: 'auto',
  },
};



================================================
FILE: storybook/stories/API/chart/AreaChart.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as AreaChartStories from './AreaChart.stories';

# AreaChart

## Parent Component

The AreaChart can be used within: `<ResponsiveContainer />`.

## Child component

The AreaChart can be used with the following child components: `<XAxis />`, `<YAxis />`, `<ReferenceArea />`, `<ReferenceDot />`, `<ReferenceLine />`, `<Brush />`, `<CartesianGrid />`, `<Legend />`, `<Tooltip />`, `<Area />`, `<Customized />` or `<validate svg elements... />`.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={AreaChartStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/AreaChart.stories.tsx
================================================
import React from 'react';
import { curveCardinal } from 'victory-vendor/d3-shape';
import { Args } from '@storybook/react';
import { Area, AreaChart, CartesianGrid, ResponsiveContainer, Tooltip, XAxis } from '../../../../src';
import { pageData, subjectData } from '../../data';
import { CategoricalChartProps } from '../props/ChartProps';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';

export default {
  argTypes: CategoricalChartProps,
  component: AreaChart,
};

export const Simple = {
  render: (args: Record<string, any>) => {
    const [myState, setMyState] = React.useState(0);
    return (
      <ResponsiveContainer width="100%" height={400}>
        <AreaChart
          {...args}
          onMouseDown={() => setMyState(myState + 1)}
          margin={{
            top: 0,
            bottom: 0,
            left: 50,
            right: 50,
          }}
        >
          <Area dataKey="pv" strokeWidth={3} stroke="#2451B7" fill="#5376C4" />
          <CartesianGrid opacity={0.1} vertical={false} />
          <Tooltip />
        </AreaChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(CategoricalChartProps),
    data: pageData,
    layout: 'horizontal',
    margin: {
      top: 0,
      bottom: 0,
      left: 50,
      right: 50,
    },
  },
};

const stepAround = curveCardinal.tension(0.5);

export const CustomType = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <AreaChart {...args}>
          <Area type={stepAround} dataKey="pv" stroke="#ff7300" fill="#ff7300" fillOpacity={0.9} />
        </AreaChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(CategoricalChartProps),
    data: pageData,
    layout: 'horizontal',
    margin: {
      top: 0,
      bottom: 0,
      left: 50,
      right: 50,
    },
  },
};

export const CategoricalAreaChart = {
  render(args: Args) {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <AreaChart {...args}>
          <Area dataKey="A" stroke="green" fill="green" fillOpacity={0.5} />
          <XAxis dataKey="subject" type="category" allowDuplicatedCategory={false} />
          <Tooltip />
        </AreaChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(CategoricalChartProps),
    data: subjectData,
    layout: 'horizontal',
    margin: {
      top: 0,
      bottom: 0,
      left: 50,
      right: 50,
    },
  },
};



================================================
FILE: storybook/stories/API/chart/BarChart.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as BarChartStories from './BarChart.stories';

# BarChart

## Parent Component

The BarChart can be used within: `<ResponsiveContainer />`.

## Child component

The BarChart can be used with the following child components: `<XAxis />`, `<YAxis />`, `<ReferenceArea />`, `<ReferenceDot />`, `<ReferenceLine />`, `<Brush />`, `<CartesianGrid />`, `<Legend />`, `<Tooltip />`, `<Bar />`, `<Customized />` or valid svg elements.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={BarChartStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/BarChart.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { Bar, BarChart, CartesianGrid, Legend, ResponsiveContainer, Tooltip, XAxis, YAxis } from '../../../../src';
import { pageData, pageDataWithNegativeNumbers } from '../../data';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { BarChartProps } from '../props/BarChartProps';

export default {
  argTypes: BarChartProps,
  component: BarChart,
};

export const Simple = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <BarChart {...args}>
          <Bar dataKey="uv" />
        </BarChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(BarChartProps),
    data: pageData,
    margin: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
    },
  },
};

export const BarInBar = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <BarChart {...args}>
          <Bar dataKey="uv" fill="green" xAxisId="one" barSize={50} />
          <XAxis xAxisId="one" />
          {/* The smaller bar must be rendered in front of the larger one to be visible. */}
          <Bar dataKey="pv" fill="red" xAxisId="two" barSize={30} />
          <XAxis xAxisId="two" hide />
        </BarChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(BarChartProps),
    data: pageData,
    margin: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
    },
  },
};

export const Stacked = {
  render: (args: Args) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <BarChart {...args}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="name" />
          <YAxis />
          <Legend />
          <Tooltip />
          <Bar dataKey="uv" stackId="a" fill="green" barSize={50} name="UV Bar" />
          <Bar dataKey="pv" stackId="a" fill="red" barSize={30} name="PV Bar" />
        </BarChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(BarChartProps),
    data: pageDataWithNegativeNumbers,
    stackOffset: 'none',
    id: 'BarChart-Stacked',
    margin: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
    },
  },
};

export const VerticalWithMultipleAxes = {
  render(args: Args) {
    return (
      <BarChart {...args}>
        <Bar dataKey="uv" xAxisId={2} fill="blue" barSize={40} />
        <Bar dataKey="pv" xAxisId={1} fill="green" barSize={30} />
        <XAxis xAxisId={1} type="number" />
        <XAxis xAxisId={2} type="number" orientation="top" />
        <YAxis type="category" />
      </BarChart>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(BarChartProps),
    data: pageData,
    width: 500,
    height: 300,
    layout: 'vertical',
  },
};



================================================
FILE: storybook/stories/API/chart/ComposedChart.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as ComposedChartStories from './ComposedChart.stories';

# ComposedChart

## Parent Component

The ComposedChart can be used within: `<ResponsiveContainer />`.

## Child component

The ComposedChart can be used with the following child components: `<XAxis />`, `<YAxis />`, `<ReferenceArea />`, `<ReferenceDot />`, `<ReferenceLine />`, `<Brush />`, `<CartesianGrid />`, `<Legend />`, `<Tooltip />`, `<Area />`, `<Line />`, `<Bar />`, `<Customized />` or valid svg elements.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={ComposedChartStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/ComposedChart.stories.tsx
================================================
import React from 'react';
import { pageData, timeData } from '../../data';
import {
  Area,
  Bar,
  Brush,
  CartesianGrid,
  ComposedChart as Composed,
  Legend,
  Line,
  LineChart,
  ReferenceDot,
  ReferenceLine,
  ResponsiveContainer,
  Scatter,
  Tooltip,
  XAxis,
  YAxis,
} from '../../../../src';
import { CategoricalChartProps } from '../props/ChartProps';

export default {
  argTypes: {
    ...CategoricalChartProps,
  },
  component: Composed,
};

// This render template can be shared across multiple stories.
// All stories use the same data, but pass different children.
const HorizontalChartTemplate = {
  render: (args: any) => {
    return (
      <ResponsiveContainer width="100%" height={300}>
        <Composed
          {...args}
          data={pageData}
          margin={{
            top: 20,
            right: 20,
            bottom: 20,
            left: 20,
          }}
        >
          {args.children}
        </Composed>
      </ResponsiveContainer>
    );
  },
};

export const SimpleChart = {
  ...HorizontalChartTemplate,
  args: {
    data: pageData,
    children: (
      <>
        <Area type="monotone" dataKey="amt" fill="#8884d8" stroke="#8884d8" />
        <Bar dataKey="uv" />
        <Line dataKey="pv" />
      </>
    ),
  },
};

export const ComplexChart = {
  ...HorizontalChartTemplate,
  args: {
    data: pageData,
    children: (
      <>
        <XAxis dataKey="name" scale="band" />
        <YAxis />
        <Legend layout="vertical" align="right" verticalAlign="middle" />
        <CartesianGrid stroke="#f5f5f5" />
        <Area type="monotone" dataKey="amt" fill="#8884d8" stroke="#8884d8" />
        <Bar dataKey="uv" fill="#ff7300" />
        <Bar dataKey="pv" barSize={20} fill="#413ea0" />
        <ReferenceLine x="Page C" stroke="red" label="Max PV PAGE" />
        <ReferenceDot x="Page C" y={1300} stroke="red" />
        <Brush>
          <LineChart>
            <Line dataKey="uv" stroke="#ff7300" dot={false} />
          </LineChart>
        </Brush>
        <Tooltip />
      </>
    ),
  },
};

export const LineBarAreaScatter = {
  ...HorizontalChartTemplate,
  args: {
    data: pageData,
    children: (
      <>
        <XAxis dataKey="name" />
        <YAxis />
        <Legend layout="vertical" align="right" verticalAlign="middle" />
        <CartesianGrid stroke="#f5f5f5" />
        <Area type="monotone" dataKey="amt" fill="#8884d8" stroke="#8884d8" />
        <Line type="monotone" dataKey="uv" stroke="#ff7300" />
        <Bar dataKey="pv" barSize={20} fill="#413ea0" />
        <Scatter dataKey="pv" fill="red" />
        <Brush />
        <Tooltip />
      </>
    ),
  },
};

export const LineBarHorizontal = {
  ...HorizontalChartTemplate,
  args: {
    data: pageData,
    children: (
      <>
        <XAxis />
        <YAxis />
        <Legend />
        <CartesianGrid stroke="#f5f5f5" />
        <Bar dataKey="pv" barSize={20} fill="#413ea0" />
        <Line type="monotone" dataKey="pv" stroke="#ff7300" />
        <Tooltip />
      </>
    ),
  },
};

export const LineBarAreaScatterTimeScale = {
  render: (args: Record<string, any>) => {
    const tickFormatter = (tick: Date) => {
      return tick.toLocaleString('en-GB', {
        /*
         * Forced timezone so that our visual diff renders the same for all contributors.
         * In real app you will probably leave timeZone undefined
         */
        timeZone: 'UTC',
        dateStyle: 'medium',
      });
    };
    return (
      <ResponsiveContainer width="100%" height={500}>
        <div style={{ width: '600px', margin: 'auto' }}>
          <p>A ComposedChart of time scale</p>
          <div className="composed-chart-wrapper">
            <Composed
              width={600}
              height={400}
              data={args.timeData}
              margin={{
                top: 20,
                right: 20,
                bottom: 20,
                left: 20,
              }}
            >
              <CartesianGrid stroke="#f5f5f5" />
              <XAxis
                dataKey="x"
                domain={[args.from.getTime(), args.to.getTime()]}
                scale="time"
                type="number"
                tick={{ fontSize: 10, fill: 'red' }}
                tickFormatter={tickFormatter}
              />
              <YAxis />
              <Legend />
              <Area type="monotone" dataKey="y" fill="#8884d8" stroke="#8884d8" />
              <Bar dataKey="y" barSize={20} fill="#413ea0" />
              <Line type="monotone" dataKey="y" stroke="#ff7300" />
              <Tooltip />
            </Composed>
          </div>
        </div>
      </ResponsiveContainer>
    );
  },
  args: {
    from: new Date('2019-07-04T00:00:00.000Z'),
    to: new Date('2019-07-10T00:00:00.000Z'),
    timeData,
    data: pageData,
  },
};

// TODO: Add a template for vertical stories.



================================================
FILE: storybook/stories/API/chart/FunnelChart.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as FunnelChartStories from './FunnelChart.stories';

# FunnelChart

## Parent Component

The FunnelChart can be used within: `<ResponsiveContainer />`.

## Child component

The FunnelChart can be used with the following child components: `<Funnel />`, `<Legend />`, `<Tooltip />`, `<Customized />` or valid svg elements.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={FunnelChartStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/FunnelChart.stories.tsx
================================================
import React from 'react';
import { Meta, StoryObj } from '@storybook/react';
import { Funnel, FunnelChart, FunnelProps, LabelList, Legend, ResponsiveContainer, Tooltip } from '../../../../src';
import { CategoricalChartProps } from '../props/ChartProps';
import { ActiveShapeProps } from '../props/ActiveShapeProps';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { pageDataWithFillColor } from '../../data';

export default {
  argTypes: {
    ...CategoricalChartProps,
    ...ActiveShapeProps,
  },
  component: FunnelChart,
};

export const Simple: Meta<FunnelProps> = {
  render: (args: Record<string, any>) => {
    const { data } = args;
    return (
      <ResponsiveContainer width="100%" height={200}>
        <FunnelChart accessibilityLayer data={data}>
          <Funnel
            width={400}
            dataKey="value"
            stroke="#424242"
            isAnimationActive
            lastShapeType="rectangle"
            shape={args.shape}
            activeShape={args.activeShape}
          >
            <LabelList dataKey="name" fill="#000" position="right" stroke="none" />
          </Funnel>
          <Tooltip />
        </FunnelChart>
      </ResponsiveContainer>
    );
  },
  args: {
    shape: {},
    activeShape: { fill: 'gold', stroke: 'purple' },
    data: [
      {
        fill: '#EEEEEE',
        name: 'A',
        value: 1009,
      },
      {
        fill: '#E0E0E0',
        name: 'B',
        value: 903,
      },
      {
        fill: '#BDBDBD',
        name: 'C',
        value: 756,
      },
      {
        fill: '#9E9E9E',
        name: 'D',
        value: 622,
      },
      {
        fill: '#757575',
        name: 'E',
        value: 602,
      },
      {
        fill: '#424242',
        name: 'F',
        value: 580,
      },
      {
        fill: '#424242',
        name: 'F',
        value: 580,
      },
    ],
  },
};

export const WithChangingDataKey: StoryObj = {
  render: (args: Record<string, any>) => {
    const [dataKey, setDataKey] = React.useState('amt');
    return (
      <>
        <form
          style={{ display: 'flex', flexDirection: 'column' }}
          onChange={e => 'value' in e.target && typeof e.target.value === 'string' && setDataKey(e.target.value)}
        >
          <label htmlFor="dataKey-amt" style={{ display: 'flex', flexDirection: 'row' }}>
            <input type="radio" id="dataKey-amt" name="dataKey" value="amt" defaultChecked={dataKey === 'amt'} />
            dataKey 1
          </label>
          <label htmlFor="dataKey-pv" style={{ display: 'flex', flexDirection: 'row' }}>
            <input type="radio" id="dataKey-pv" name="dataKey" value="pv" defaultChecked={dataKey === 'pv'} />
            dataKey 2
          </label>
          <label htmlFor="dataKey-empty" style={{ display: 'flex', flexDirection: 'row' }}>
            <input
              type="radio"
              id="dataKey-empty"
              name="dataKey"
              value="hidden"
              defaultChecked={dataKey === 'hidden'}
            />
            Hidden
          </label>
        </form>
        <FunnelChart {...args}>
          <Legend />
          <Funnel
            dataKey={dataKey}
            fill="orange"
            fillOpacity={0.5}
            stroke="blue"
            strokeDasharray="3 3"
            lastShapeType="rectangle"
            label={{ dataKey: 'name', stroke: 'none', fill: 'black', strokeDasharray: '0 0' }}
          />
          <Tooltip />
        </FunnelChart>
      </>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(CategoricalChartProps),
    data: pageDataWithFillColor,
    width: 360,
    height: 360,
  },
};



================================================
FILE: storybook/stories/API/chart/LineChart.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as LineChartStories from './LineChart.stories';

# LineChart

## Parent Component

The LineChart can be used within: `<ResponsiveContainer />`.

## Child component

The LineChart can be used with the following child components: `<XAxis />`, `<YAxis />`, `<ReferenceArea />`, `<ReferenceDot />`, `<ReferenceLine />`, `<Brush />`, `<CartesianGrid />`, `<Legend />`, `<Tooltip />`, `<Line />`, `<Customized />` or valid svg elements.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={LineChartStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/LineChart.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { pageData } from '../../data';
import { Line, LineChart, ResponsiveContainer, Tooltip, XAxis } from '../../../../src';
import { CategoricalChartProps } from '../props/ChartProps';

export default {
  argTypes: CategoricalChartProps,
  component: LineChart,
};

export const Simple = {
  render: (args: Args) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <LineChart {...args}>
          <Line dataKey="uv" />
        </LineChart>
      </ResponsiveContainer>
    );
  },
  args: {
    data: pageData,
  },
};

export const SynchronizedTooltip = {
  render: (args: Args) => {
    return (
      <div>
        <LineChart {...args} id="BookOne" className="BookOne">
          <Line isAnimationActive={false} name="BookOne" type="monotone" dataKey="uv" stroke="#111" />
          <XAxis dataKey="name" />
          <Tooltip active />
        </LineChart>
        <LineChart {...args} id="BookTwo" className="BookTwo">
          <Line isAnimationActive={false} name="BookTwo" type="monotone" dataKey="uv" stroke="#ff7300" />
          <XAxis dataKey="name" />
          <Tooltip />
        </LineChart>
      </div>
    );
  },
  args: {
    data: pageData,
    syncId: 'example-syncId',
    width: 400,
    height: 400,
  },
};



================================================
FILE: storybook/stories/API/chart/PieChart.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as PieChartStories from './PieChart.stories';

# PieChart

## Parent Component

The PieChart can be used within: `<ResponsiveContainer />`.

## Child component

The PieChart can be used with the following child components: `<PolarAngleAxis />`, `<PolarRadiusAxis />`, `<PolarGrid />`, `<Legend />`, `<Tooltip />`, `<Pie />`, `<Customized />` or valid svg elements.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={PieChartStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/PieChart.stories.tsx
================================================
import React, { useEffect, useState } from 'react';
import { StoryContext } from '@storybook/react';
import { Legend, Pie, PieChart, ResponsiveContainer, Tooltip } from '../../../../src';
import { pageData } from '../../data';
import { CategoricalChartProps } from '../props/ChartProps';
import { ActiveShapeProps } from '../props/ActiveShapeProps';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { RechartsHookInspector } from '../../../storybook-addon-recharts/RechartsHookInspector';

export default {
  argTypes: {
    ...CategoricalChartProps,
    activeIndex: ActiveShapeProps.activeIndex,
    activeShape: ActiveShapeProps.activeShape,
  },
  component: PieChart,
};

export const Simple = {
  render: (args: Record<string, any>, context: StoryContext) => {
    const { data, activeShape } = args;
    return (
      <ResponsiveContainer width="100%" height={400}>
        <PieChart {...args}>
          <Pie data={data} dataKey="uv" activeShape={activeShape} />
          <Tooltip defaultIndex={3} />
          <RechartsHookInspector rechartsInspectorEnabled={context.rechartsInspectorEnabled} />
        </PieChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(CategoricalChartProps),
    data: pageData,
    activeShape: { fill: 'red' },
    margin: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
    },
  },
};

export const Donut = {
  render: (args: Record<string, any>, context: StoryContext) => {
    const { data } = args;
    return (
      <ResponsiveContainer width="100%" height={400}>
        <PieChart {...args}>
          <Pie data={data} dataKey="uv" nameKey="name" innerRadius={50} outerRadius={80} />
          <RechartsHookInspector rechartsInspectorEnabled={context.rechartsInspectorEnabled} />
        </PieChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(CategoricalChartProps),
    data: pageData,
  },
};

export const ChangingDataKey = {
  render: (args: Record<string, any>, context: StoryContext) => {
    const data1 = [
      { x: { value: 1 }, name: 'x1', fill: 'blue' },
      { x: { value: 2 }, name: 'x2', fill: 'red' },
      { x: { value: 3 }, name: 'x3', fill: 'green' },
    ];
    const data2 = [
      { y: { value: 3 }, name: 'y1', fill: 'blue' },
      { y: { value: 2 }, name: 'y2', fill: 'red' },
      { y: { value: 1 }, name: 'y3', fill: 'green' },
    ];

    const dataKey1 = (d: any) => {
      return d.x.value;
    };
    const dataKey2 = (d: any) => {
      return d.y.value;
    };

    const [useData2, setUseData2] = useState(false);
    const [visible, setVisible] = useState(true);
    useEffect(() => {
      console.log('ChangingDataKey mounted');
      return () => {
        console.log('ChangingDataKey unmounted');
      };
    }, []);

    return (
      <>
        <button
          type="button"
          onClick={() => {
            setUseData2(false);
            setVisible(true);
          }}
        >
          Use data1
        </button>
        <button
          type="button"
          onClick={() => {
            setUseData2(true);
            setVisible(true);
          }}
        >
          Use data2
        </button>
        <button
          type="button"
          onClick={() => {
            setVisible(false);
          }}
        >
          Hide
        </button>
        <PieChart {...args} data={useData2 ? data2 : data1}>
          <Tooltip />
          <Legend />
          <RechartsHookInspector rechartsInspectorEnabled={context.rechartsInspectorEnabled} />
          <Pie
            data={useData2 ? data2 : data1}
            name="Animated line"
            hide={!visible}
            type="monotone"
            dataKey={useData2 ? dataKey2 : dataKey1}
            stroke="#8884d8"
            strokeDasharray="5 5"
            label={{ fill: 'red' }}
            animationDuration={3000}
          />
        </PieChart>
      </>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(CategoricalChartProps),
    width: 500,
    height: 300,
    margin: {
      top: 30,
      right: 30,
      left: 20,
      bottom: 5,
    },
  },
};



================================================
FILE: storybook/stories/API/chart/RadarChart.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as RadarChartStories from './RadarChart.stories';

# RadarChart

## Parent Component

The RadarChart can be used within: `<ResponsiveContainer />`.

## Child component

The RadarChart can be used with the following child components: `<PolarAngleAxis />`, `<PolarRadiusAxis />`, `<PolarGrid />`, `<Legend />`, `<Tooltip />`, `<Radar />`, `<Customized />` or valid svg elements.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={RadarChartStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/RadarChart.stories.tsx
================================================
import React from 'react';
import { pageData } from '../../data';
import { PolarAngleAxis, PolarGrid, PolarRadiusAxis, Radar, RadarChart, Tooltip } from '../../../../src';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { RadarChartProps } from '../props/RadarChartProps';

export default {
  argTypes: RadarChartProps,
  component: RadarChart,
};

export const Simple = {
  render: (args: Record<string, any>) => {
    return (
      <RadarChart {...args}>
        <PolarAngleAxis dataKey="name" />
        <PolarRadiusAxis />
        <PolarGrid />
        <Tooltip defaultIndex={1} />
        <Radar dataKey="uv" stroke="green" strokeOpacity={0.7} fill="green" fillOpacity={0.5} strokeWidth={3} />
      </RadarChart>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(RadarChartProps),
    data: pageData,
    width: 800,
    height: 300,
  },
};



================================================
FILE: storybook/stories/API/chart/RadialBarChart.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as RadialBarChartStories from './RadialBarChart.stories';

# RadialBarChart

## Parent Component

The RadialBarChart can be used within: `<ResponsiveContainer />`.

## Child component

The RadialBarChart can be used with the following child components: `<PolarAngleAxis />`, `<PolarRadiusAxis />`, `<PolarGrid />`, `<Legend />`, `<Tooltip />`, `<RadialBar />`, `<Customized />` or valid svg elements.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={RadialBarChartStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/RadialBarChart.stories.tsx
================================================
/* eslint-disable jsx-a11y/no-noninteractive-element-interactions */
/* eslint-disable jsx-a11y/click-events-have-key-events */
import { StoryContext, StoryObj } from '@storybook/react';
import React, { useState } from 'react';
import { pageData, pageDataWithFillColor } from '../../data';
import { Tooltip, RadialBar, RadialBarChart, ResponsiveContainer, Cell, Legend } from '../../../../src';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { RadialBarChartProps } from '../props/RadialBarChartProps';
import { RechartsHookInspector } from '../../../storybook-addon-recharts/RechartsHookInspector';
import { StorybookArgs } from '../../../StorybookArgs';

export default {
  argTypes: RadialBarChartProps,
  component: RadialBarChart,
};

export const Simple: StoryObj = {
  render: (args: StorybookArgs, context: StoryContext) => {
    return (
      <RadialBarChart {...args}>
        <RadialBar dataKey="uv" activeShape={{ fill: 'red' }} />
        <Tooltip defaultIndex={3} />
        <RechartsHookInspector rechartsInspectorEnabled={context.rechartsInspectorEnabled} />
      </RadialBarChart>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(RadialBarChartProps),
    data: pageData,
    width: 800,
    height: 400,
  },
};

export const WithCustomizedClickLegendEvent = {
  render: (args: Record<string, any>) => {
    const { data } = args;
    const [selectedRadialBar, setSelectedRadialBar] = useState('35-39');

    return (
      <ResponsiveContainer width="100%" height="100%">
        <RadialBarChart {...args}>
          <RadialBar background dataKey="uv">
            {data.map((entry: { name: string }) => (
              <Cell key={`cell-${entry.name}`} opacity={selectedRadialBar === entry.name ? 1 : 0.1} />
            ))}
          </RadialBar>
          <Legend
            iconSize={10}
            width={120}
            height={140}
            layout="vertical"
            verticalAlign="middle"
            content={({ payload }) => (
              <ul>
                {payload?.map((entry: { value: string; color: string }) => {
                  return (
                    <li
                      onClick={() => setSelectedRadialBar(entry.value)}
                      key={`item-${entry.value}`}
                      style={{
                        color: entry.color,
                        opacity: selectedRadialBar === entry.value ? 1 : 0.2,
                      }}
                    >
                      {entry.value}
                    </li>
                  );
                })}
              </ul>
            )}
          />
        </RadialBarChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(RadialBarChartProps),
    data: pageDataWithFillColor,
    width: 500,
    height: 300,
    cx: 150,
    cy: 150,
    innerRadius: 20,
    outerRadius: 140,
    barSize: 10,
  },
};



================================================
FILE: storybook/stories/API/chart/Sankey.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as SankeyStories from './Sankey.stories';

# Sankey

## Child component

The Sankey can be used with the following child components: `<Tooltip />`.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={SankeyStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/Sankey.stories.tsx
================================================
import React from 'react';
import { complexNodeLinkData, nodeLinkData } from '../../data';
import { ResponsiveContainer, Sankey, Tooltip } from '../../../../src';
import { NodeProps } from '../../../../src/chart/Sankey';
import { data, margin } from '../props/ChartProps';
import { dataKey } from '../props/CartesianComponentShared';

export default {
  argTypes: {
    iterations: { description: 'TODO' },
    link: { description: 'TODO' },
    linkCurvature: { description: 'TODO' },
    nameKey: { description: 'TODO' },
    node: { description: 'TODO' },
    nodePadding: { description: 'TODO' },
    nodeWidth: { description: 'TODO' },
    dataKey,
    margin,
    data,
    sort: { description: 'Whether to sort the data or not' },
  },
  component: Sankey,
};

export const Simple = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <Sankey data={nodeLinkData} {...args}>
          <Tooltip />
        </Sankey>
      </ResponsiveContainer>
    );
  },
  args: {
    data: nodeLinkData,
  },
};

export const Customized = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <Sankey data={nodeLinkData} {...args} />
      </ResponsiveContainer>
    );
  },
  args: {
    data: nodeLinkData,
    nodeWidth: 10,
    nodePadding: 60,
    height: 500,
    width: 960,
  },
};

export const CustomNodeAndLink = {
  render: (args: Record<string, any>) => {
    const colors = ['#3C898E', '#486DF0', '#6F50E5'];

    type CustomNodePayload = {
      name: string;
      sourceNodes: number[];
      sourceLinks: number[];
      targetLinks: number[];
      targetNodes: number[];
      value: number;
      depth: number;
      x: number;
      dx: number;
      y: number;
      dy: number;
    };

    const CustomNode = (props: NodeProps): React.ReactElement => {
      return (
        <rect
          x={props.x + 4}
          y={props.y - 2}
          width={props.width - 8}
          height={props.height + 4}
          fill={colors[props.payload.depth % colors.length]}
          rx={2.5}
        />
      );
    };

    type CustomLinkPayload = {
      source: CustomNodePayload;
      target: CustomNodePayload;
      value: number;
      dy: number;
      sy: number;
      ty: number;
    };

    const CustomLink = (props: {
      sourceX: number;
      targetX: number;
      sourceY: number;
      targetY: number;
      sourceControlX: number;
      targetControlX: number;
      sourceRelativeY: number;
      targetRelativeY: number;
      linkWidth: number;
      index: number;
      payload: CustomLinkPayload;
    }) => {
      return (
        <g>
          <path
            d={`
  M${props.sourceX},${props.sourceY}
  C${props.sourceControlX},${props.sourceY} ${props.targetControlX},${props.targetY} ${props.targetX},${props.targetY}`}
            fill="none"
            stroke={colors[props.payload.source.depth % colors.length]}
            strokeOpacity={0.4}
            strokeWidth={props.linkWidth}
            strokeLinecap="butt"
          />
          <foreignObject
            x={props.sourceX}
            y={props.targetY - props.linkWidth / 2}
            width={Math.max(props.targetX, props.sourceX) - Math.min(props.targetX, props.sourceX)}
            height={props.linkWidth}
            style={{ overflow: 'visible' }}
          >
            <div
              style={{
                boxSizing: 'border-box',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'flex-end',
                width: '100%',
                height: '100%',
                overflow: 'visible',
                padding: '0.5em',
                gap: 8,
              }}
            >
              <div
                style={{
                  fontSize: 10,
                  fontFamily: 'sans-serif',
                  textAlign: 'center',
                  backgroundColor: '#f1f5fe80',
                  padding: '0.25em 0.5em',
                  borderRadius: 4,
                  position: 'relative',
                  zIndex: 1,
                }}
              >
                {props.payload.target.name ? `${props.payload.target.name}: ` : ''}
                {props.payload.value}
                &nbsp;€
              </div>
            </div>
          </foreignObject>
        </g>
      );
    };

    return (
      <ResponsiveContainer width="100%" height={400}>
        <Sankey data={complexNodeLinkData} node={CustomNode} link={CustomLink} {...args} />
      </ResponsiveContainer>
    );
  },
  args: {
    data: complexNodeLinkData,
    nodeWidth: 16,
    nodePadding: 14,
    height: 500,
    width: 960,
    sort: false,
    margin: { top: 20, left: 20, right: 20, bottom: 20 },
  },
};



================================================
FILE: storybook/stories/API/chart/ScatterChart.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as ScatterChartStories from './ScatterChart.stories';

# ScatterChart

## Parent Component

The ScatterChart can be used within: `<ResponsiveContainer />`.

## Child component

The ScatterChart can be used with the following child components: `<XAxis />`, `<YAxis />`, `<ZAxis />`, `<ReferenceArea />`, `<ReferenceDot />`, `<ReferenceLine />`, `<Brush />`, `<CartesianGrid />`, `<Legend />`, `<Tooltip />`, `<Scatter />`, `<Customized />` or valid svg elements.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={ScatterChartStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/ScatterChart.stories.tsx
================================================
import React from 'react';
import { coordinateData } from '../../data';
import { ResponsiveContainer, Scatter, ScatterChart, XAxis, YAxis } from '../../../../src';
import { CategoricalChartProps } from '../props/ChartProps';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';

export default {
  argTypes: CategoricalChartProps,
  component: ScatterChart,
};

export const Simple = {
  render: (args: Record<string, any>) => {
    const { data, ...rest } = args;
    return (
      <ResponsiveContainer width="100%" height={400}>
        <ScatterChart {...rest}>
          <XAxis dataKey="x" />
          <YAxis dataKey="y" />
          <Scatter data={data} />
        </ScatterChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(CategoricalChartProps),
    data: coordinateData,
    margin: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
    },
  },
};



================================================
FILE: storybook/stories/API/chart/SunburstChart.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as SunburstStories from './SunburstChart.stories';

# Sunburst

The sunburst is a hierarchical chart, similar to a treemap, plotted in polar coordinates.
Sunburst charts effectively convey the hierarchical relationships and proportions within each level.
It is easy to see all the middle layers in the hierarchy, which might get lost in other visualizations.
For some datasets, the radial layout may be more visually appealing and intuitive than a traditional treemap.

## Parent Component

The Sunburst can be used within: `<ResponsiveContainer />`.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={SunburstStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/SunburstChart.stories.tsx
================================================
import React from 'react';
import { ResponsiveContainer, SunburstChart, Tooltip } from '../../../../src';
import { SunburstData } from '../../../../src/chart/SunburstChart';
import { CategoricalChartProps, ChartSizeProps, data, dataKey, margin } from '../props/ChartProps';
import { PolarChartProps } from '../props/PolarChartProps';

const { innerRadius, outerRadius, cx, cy, startAngle, endAngle } = PolarChartProps;

const { onClick, onMouseEnter, onMouseLeave, className } = CategoricalChartProps;

export default {
  argTypes: {
    data,
    margin,
    ...ChartSizeProps,
    dataKey,
    innerRadius,
    outerRadius,
    cx,
    cy,
    startAngle,
    endAngle,
    onClick,
    onMouseEnter,
    onMouseLeave,
    className,
  },
  component: SunburstChart,
};

const hierarchy: SunburstData = {
  name: 'Root',
  value: 100,
  children: [
    {
      name: 'Child1',
      fill: '#264653',
      value: 30,
      children: [
        {
          name: 'third child',
          value: 10,
        },
        {
          name: 'another child',
          value: 5,
        },
        {
          name: 'next child',
          value: 15,
          children: [
            {
              name: 'third level child',
              value: 5,
            },
            {
              name: 'third level child',
              value: 5,
            },
            {
              name: 'third level child',
              value: 5,
              children: [{ name: 'level 4', value: 2 }],
            },
          ],
        },
      ],
    },
    {
      name: 'Child2',
      fill: '#2a9d8f',
      value: 20,
      children: [
        {
          name: 'another child',
          value: 10,
        },
        {
          name: 'next child',
          value: 10,
          children: [
            { name: 'level 3 of child 2', value: 5 },
            { name: 'level 3 of child 2', value: 3 },
            { name: 'level 3 of child 2', value: 2 },
          ],
        },
      ],
    },
    {
      name: 'Child3',
      fill: '#e9c46a',
      value: 20,
    },
    {
      name: 'Child4',
      fill: '#F4A261',
      value: 10,
      children: [
        { name: 'child4 child', value: 5 },
        { name: 'child4 child', value: 5 },
      ],
    },
    {
      name: 'Child5',
      fill: '#e76f51',
      value: 20,
    },
  ],
};

export const Sunburst = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={450}>
        <SunburstChart {...args} data={args.data} />
      </ResponsiveContainer>
    );
  },
  args: {
    data: hierarchy,
    innerRadius: 40,
  },
};

export const WithStartAndEndAngle = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={450}>
        <SunburstChart {...args} data={args.data} />
      </ResponsiveContainer>
    );
  },
  args: {
    data: hierarchy,
    innerRadius: 40,
    startAngle: 90,
    endAngle: 270,
  },
};

export const WithTooltip = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={450}>
        <SunburstChart {...args} data={args.data}>
          <Tooltip />
        </SunburstChart>
      </ResponsiveContainer>
    );
  },
  args: {
    data: hierarchy,
    innerRadius: 40,
  },
};



================================================
FILE: storybook/stories/API/chart/Treemap.mdx
================================================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as TreemapStories from './Treemap.stories';

# Treemap

## Parent Component

The Treemap can be used within: `<ResponsiveContainer />`.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={TreemapStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/chart/Treemap.stories.tsx
================================================
import React from 'react';
import { sizeData, treemapData } from '../../data';
import { ResponsiveContainer, Tooltip, Treemap } from '../../../../src';
import { ChartSizeProps, data } from '../props/ChartProps';
import { animationBegin, animationDuration, animationEasing, isAnimationActive } from '../props/AnimationProps';
import { isUpdateAnimationActive } from '../props/RectangleProps';
import { onAnimationEnd, onAnimationStart, onClick, onMouseEnter, onMouseLeave } from '../props/EventHandlers';
import { dataKey } from '../props/CartesianComponentShared';
import { GeneralStyle } from '../props/Styles';

export default {
  argTypes: {
    type: {
      description:
        'Rendering mode of the Treemap. Options: "flat" (show entire treemap) or "nest" (show depth-1 nodes, allowing click-through).',
    },
    style: {
      description: 'Custom inline styles for the Treemap component. Accepts a JavaScript object with CSS properties.',
    },
    nestIndexContent: {
      description:
        'Custom content for the nest index in "nest" mode. Accepts a React element or a function that returns a React element.',
    },
    nameKey: {
      ...dataKey, // The name key is a data key.
      description: "The accessor of the treemap's rectangles' name.",
    },
    content: {
      description: "The content of the treemap's rectangles.",
      table: {
        type: {
          summary: 'ReactElement | Function',
          defaultValue: null,
        },
        category: 'General',
      },
    },
    className: {
      table: {
        category: 'Internal',
      },
    },
    fill: GeneralStyle.fill,
    stroke: GeneralStyle.stroke,
    colorPanel: {
      description: "The color panel is used to render the color of the treemap's rectangles.",
    },
    aspectRatio: {
      description: "The treemap will try to keep every single rectangle's aspect ratio near the aspectRatio given.",
      table: {
        type: {
          summary: 'Number',
          defaultValue: null,
        },
        category: 'General',
      },
    },
    animationBegin,
    ...ChartSizeProps,
    animationDuration,
    animationEasing,
    data,
    dataKey,
    isAnimationActive,
    isUpdateAnimationActive,
    onAnimationEnd,
    onAnimationStart,
    onClick,
    onMouseEnter,
    onMouseLeave,
  },
  component: Treemap,
};

export const Simple = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <Treemap {...args} />
      </ResponsiveContainer>
    );
  },
  args: {
    data: sizeData,
    dataKey: 'size',
    nameKey: 'name',
    isAnimationActive: false,
  },
};

export const WithTooltip = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <Treemap {...args}>
          <Tooltip />
        </Treemap>
      </ResponsiveContainer>
    );
  },
  args: {
    data: sizeData,
    dataKey: 'size',
    nameKey: 'name',
    isAnimationActive: false,
  },
};

const colors = ['#8889DD', '#9597E4', '#8DC77B', '#A5D297', '#E2CF45', '#F8C12D'];

export const WithCustomContent = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <Treemap
          {...args}
          dataKey="size"
          stroke="#fff"
          fill="#8884d8"
          content={props => {
            const { root, depth, x, y, width, height, index, name } = props;

            return (
              <g>
                <rect
                  x={x}
                  y={y}
                  width={width}
                  height={height}
                  style={{
                    fill: depth < 2 ? colors[Math.floor((index / root.children.length) * 6)] : '#ffffff00',
                    stroke: '#fff',
                    strokeWidth: 2 / (depth + 1e-10),
                    strokeOpacity: 1 / (depth + 1e-10),
                  }}
                />
                {depth === 1 ? (
                  <text x={x + width / 2} y={y + height / 2 + 7} textAnchor="middle" fill="#fff" fontSize={14}>
                    {name}
                  </text>
                ) : null}
                {depth === 1 ? (
                  <text x={x + 4} y={y + 18} fill="#fff" fontSize={16} fillOpacity={0.9}>
                    {index + 1}
                  </text>
                ) : null}
              </g>
            );
          }}
        >
          <Tooltip />
        </Treemap>
      </ResponsiveContainer>
    );
  },
  args: {
    data: treemapData,
    dataKey: 'size',
    isAnimationActive: false,
  },
};



================================================
FILE: storybook/stories/API/component/Cell.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Cell.stories';

# Cell

Cell can be wrapped by Pie, Bar, or RadialBar to specify attributes of each child. 
In Pie, for example, we can specify the attributes of each child node through data,
but the props of Cell have higher priority.

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Components
The Cell can be used within a `<Bar />`, `<Scatter />`, `<Pie />`, `<RadialBar />` or a `<Funnel />`

## Properties

<Controls of={ComponentStories.API} />


================================================
FILE: storybook/stories/API/component/Cell.stories.tsx
================================================
import React from 'react';
import { Cell, Pie, PieChart, ResponsiveContainer } from '../../../../src';
import { GeneralStyle } from '../props/Styles';
import { EventHandlers } from '../props/EventHandlers';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { pageData } from '../../data';

export default {
  argTypes: {
    ...GeneralStyle,
    ...EventHandlers,
    // Deprecated
    dangerouslySetInnerHTML: { table: { category: 'Deprecated', disable: true } },
  },
  component: Cell,
};

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', 'red', 'pink', 'url(#pattern-checkers)'];

export const API = {
  render: (args: Record<string, any>) => {
    const surfaceDimension = 400;
    return (
      <ResponsiveContainer width="100%" height={surfaceDimension}>
        <PieChart>
          <defs>
            <pattern id="pattern-checkers" x="0" y="0" width="10" height="10" patternUnits="userSpaceOnUse">
              <rect x="0" width="5" height="5" y="0" />
              <rect x="100" width="5" height="5" y="100" />
            </pattern>
          </defs>
          <Pie data={pageData} dataKey="uv" label>
            {pageData.map((entry, index) => (
              <Cell key={`cell-pie-${entry.pv}-${entry.uv}`} fill={COLORS[index]} {...args} />
            ))}
          </Pie>
        </PieChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(GeneralStyle),
    ...getStoryArgsFromArgsTypesObject(EventHandlers),
  },
};



================================================
FILE: storybook/stories/API/component/Label.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Label.stories';

# Label

The Label component is used to display a label for a component.

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Components
The Label can be used within a `<XAxis />`, `<YAxis />`, `<ReferenceArea />`, `<ReferenceDot />`, `<ReferenceLine />`, `<Pie />` or a `<PolarRadiusAxis />`


## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/component/Label.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { ResponsiveContainer, Label, Surface } from '../../../../src';

const LabelProps: Args = {
  viewBox: {
    description: 'The box of viewing area, usually calculated internally.',
    table: {
      control: { type: 'String | number' },
      summary: '{ x: number, y: number, width: number, height: number }',
      category: 'General',
    },
  },
  formatter: {
    description: 'The formatter function of label value which has only one parameter - the value of label.',
    table: {
      control: { type: 'Function' },
      category: 'General',
    },
  },
  value: {
    description: 'The value of label, which can be specified by this props or the children of <Label />',
    table: {
      control: { type: 'String | Number' },
      summary: '<Label value="any" />',
      category: 'General',
    },
  },
  position: {
    description: 'The position of label relative to the view box. (Optional)',
    table: {
      control: { type: 'String | Number' },
      summary:
        'top, left, right, bottom, inside, outside, insideLeft, ' +
        'insideRight, insideTop, insideBottom, insideTopLeft, ' +
        'insideBottomLeft, insideTopRight, insideBottomRight, ' +
        'insideStart, insideEnd, end, center, centerTop, centerBottom, middle',
      category: 'General',
    },
  },
  offset: {
    description: 'The offset to the specified "position"',
    table: {
      control: { type: 'Number' },
      defaultValue: 5,
      category: 'General',
    },
  },

  children: {
    description: 'The value of label, which can be specified by this props or the props "value". (Optional)',
    table: {
      control: { type: 'String | Number' },
      summary: '<Label content={<CustomizedLabel external={external} />} />',
      category: 'General',
    },
  },

  content: {
    description:
      'If set a React element, the option is the custom react element of ' +
      'rendering label. If set a function, the function will be called to render label content. (Optional)',
    table: {
      control: { type: 'ReactElement | Function' },
      category: 'General',
    },
  },

  id: {
    description:
      'The unique id of this component, which will be used to generate ' +
      'unique clip path id internally. This props is suggested to be set in SSR. (Optional)',
    table: {
      control: { type: 'String' },
      category: 'General',
    },
  },
};

export default {
  argTypes: {
    ...LabelProps,
  },
  component: Label,
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={200}>
        <Surface viewBox={args.viewBox} width={0} height={0}>
          <Label {...args} />
        </Surface>
      </ResponsiveContainer>
    );
  },
  args: {
    viewBox: {
      x: 50,
      y: 50,
      width: 100,
      height: 100,
    },
    value: 'Label value',
    position: 'center',
    offset: 5,
  },
};



================================================
FILE: storybook/stories/API/component/LabelList.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './LabelList.stories';

# LabelList

The LabelList component is used to display a label for a component.

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Components
The LabelList can be used within a `<Area />`, `<Bar />`, `<Line />`, `<Scatter />`, `<Pie />`, `<Radar />` or a `<RadialBar />`


## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/component/LabelList.stories.tsx
================================================
import React from 'react';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { ResponsiveContainer, LabelList, LineChart, Line } from '../../../../src';
import { pageData } from '../../data';
import { LabelListProps } from '../props/LabelListProps';

export default {
  argTypes: {
    ...LabelListProps,
  },
  component: LabelList,
};

export const API = {
  render: (args: Record<string, any>) => {
    const [surfaceWidth, surfaceHeight] = [600, 300];
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <LineChart
          width={surfaceWidth}
          height={surfaceHeight}
          margin={{
            top: 20,
            right: 20,
            bottom: 20,
            left: 20,
          }}
          data={pageData}
        >
          {/* The target component */}
          <Line dataKey="uv">
            <LabelList {...args} />
          </Line>
        </LineChart>
      </ResponsiveContainer>
    );
  },
  args: {
    // This API story should have explicit values for all props
    dataKey: 'uv',
    position: 'top',
    ...getStoryArgsFromArgsTypesObject(LabelListProps),
  },
};



================================================
FILE: storybook/stories/API/component/Legend.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Legend.stories';

# Legend

The Legend component is used to display legend of the chart.

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>


## Parent Components
The Legend can be used within a `<AreaChart />`, `<BarChart />`, `<LineChart />`, `<ComposedChart />`, `<PieChart />`, `<RadarChart />`, `<RadialBarChart />` or a `<ScatterChart />`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />


================================================
FILE: storybook/stories/API/component/Legend.stories.tsx
================================================
import React, { useState } from 'react';
import { Args } from '@storybook/react';
import { ResponsiveContainer, LineChart, Line, Legend, AreaChart, Area, YAxis, Tooltip, XAxis } from '../../../../src';
import { rechartsPackageDownloads, pageData } from '../../data';
import { LegendProps } from '../props/Legend';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';

export default {
  argTypes: LegendProps,
  component: Legend,
};

export const API = {
  render: (args: Args) => {
    const [surfaceWidth, surfaceHeight] = [600, 300];
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <LineChart
          width={surfaceWidth}
          height={surfaceHeight}
          margin={{
            top: 20,
            right: 20,
            bottom: 20,
            left: 20,
          }}
          data={pageData}
        >
          {/* The target component */}
          <Legend {...args} />
          <Line dataKey="uv" stroke="#8884d8" name="Series 1 (UV)" />
          <Line dataKey="pv" stroke="#82ca9d" name="Series 2 (PV)" />
        </LineChart>
      </ResponsiveContainer>
    );
  },
  args: getStoryArgsFromArgsTypesObject(LegendProps),
};

export const LegendPortal = {
  render: (args: Args) => {
    const [, surfaceHeight] = [600, 300];
    const [legendPortal, setLegendPortal] = useState<HTMLDivElement | null>(null);

    return (
      <div style={{ display: 'flex', width: '100%', height: surfaceHeight }}>
        <div
          style={{ width: '100%', height: '100%' }}
          ref={node => {
            if (legendPortal == null && node != null) {
              setLegendPortal(node);
            }
          }}
        >
          <h2>Recharts Downloads</h2>
          We can render whatever we want render with the Legend items. This chart represents Recharts downloads from
          August 2023 to August 2024.
        </div>
        <div style={{ width: '100%', height: '100%' }}>
          <ResponsiveContainer width="100%" height={surfaceHeight}>
            <AreaChart
              margin={{
                top: 20,
                right: 20,
                bottom: 20,
                left: 20,
              }}
              data={rechartsPackageDownloads}
            >
              {/* The target component */}
              {legendPortal && (
                <Legend
                  {...args}
                  wrapperStyle={{ marginTop: 20 }}
                  formatter={() => 'Recharts Downloads'}
                  portal={legendPortal}
                />
              )}

              <YAxis domain={[0, 'auto']} tickFormatter={value => value?.toLocaleString()} />
              <XAxis
                dataKey="day"
                interval="equidistantPreserveStart"
                tickFormatter={value => new Date(value).toLocaleDateString()}
              />
              <Area type="monotone" dataKey="downloads" stroke="green" fill="green" fillOpacity={0.2} />
              <Tooltip
                formatter={value => {
                  return value.toLocaleString();
                }}
                labelFormatter={value => new Date(value).toLocaleDateString()}
              />
            </AreaChart>
          </ResponsiveContainer>
        </div>
      </div>
    );
  },
  args: getStoryArgsFromArgsTypesObject(LegendProps),
};



================================================
FILE: storybook/stories/API/component/Text.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Text.stories';

# Text

This component is used to render text in a paragraph, but can also be used to render text in other contexts, such as in a `Label`.

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>



## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/component/Text.stories.tsx
================================================
import React from 'react';
import { ResponsiveContainer, Surface, Text } from '../../../../src';
import { TextProps } from '../props/TextProps';

export default {
  argTypes: {
    ...TextProps,
  },
  component: Text,
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width={500} height={300}>
        <Surface width={500} height={80}>
          <Text {...args}>{args.content}</Text>
        </Surface>
      </ResponsiveContainer>
    );
  },
  args: {
    breakAll: false,
    lineHeight: '1em',
    maxLines: 3,
    scaleToFit: false,
    textAnchor: 'start',
    verticalAnchor: 'start',
    angle: 0,
    width: 200,
    y: 50,
    x: 50,
    content: 'This is really, really, really, really, really, really, really, really, really long text',
  },
};



================================================
FILE: storybook/stories/API/component/Tooltip.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Tooltip.stories.tsx';

# Tooltip

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component

The Tooltip can be used within:
`<AreaChart />`,
`<BarChart />`,
`<LineChart />`,
`<ComposedChart />`,
`<PieChart />`,
`<RadarChart />`,
`<RadialBarChart />`,
`<ScatterChart />`, or
`<Treemap />`

## Properties

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/component/Tooltip.stories.tsx
================================================
import React from 'react';
import { Line, LineChart, ResponsiveContainer, Tooltip } from '../../../../src';
import { pageData } from '../../data';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { TooltipProps } from '../props/TooltipProps';

export default {
  argTypes: TooltipProps,
  component: Tooltip,
};

export const API = {
  render: (args: Record<string, any>) => {
    const [surfaceWidth, surfaceHeight] = [600, 300];
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <LineChart
          width={surfaceWidth}
          height={surfaceHeight}
          margin={{
            top: 20,
            right: 20,
            bottom: 20,
            left: 20,
          }}
          data={pageData}
        >
          <Line dataKey="uv" />
          {/* The target component */}
          <Tooltip {...args} />
        </LineChart>
      </ResponsiveContainer>
    );
  },
  args: {
    // This API story should have explicit values for all props
    ...getStoryArgsFromArgsTypesObject(TooltipProps),
    trigger: 'hover',
    shared: false,
    useTranslate3d: false,
  },
};



================================================
FILE: storybook/stories/API/hooks/dimensions.mdx
================================================
import { Meta, Story, Canvas } from '@storybook/blocks';
import * as ComponentStories from './dimensions.stories';

<Meta of={ComponentStories} />

# `useChartWidth`, `useChartHeight`

The `useChartWidth` hook returns the width of the chart in pixels. `useChartHeight` returns the height of the chart in pixels.

If you are using chart with hardcoded `width` and `height` props, then the width returned will be the same
as the `width` and `height` prop on the main chart element.

If you are using a chart with a `ResponsiveContainer`, the width and height will be the size of the chart
as the ResponsiveContainer has decided it would be.

If the chart has any axes or legend, the `width` and `height` will be the size of the chart
including the axes and legend.

The dimensions do not scale, meaning as user zoom in and out, the width/height number will not change
as the chart gets visually larger or smaller.

<Canvas>
  <Story name="WithAxesAndLegend" of={ComponentStories} />
</Canvas>

## Parent Component

The hooks can be used within any chart:
- `<AreaChart/>`
- `<BarChart/>`
- `<ComposedChart/>`
- `<FunnelChart/>`
- `<LineChart/>`
- `<PieChart/>`
- `<RadarChart/>`
- `<RadialBarChart/>`
- `<Sankey/>`
- `<ScatterChart/>`
- `<SunburstChart/>`
- `<Treemap/>`



================================================
FILE: storybook/stories/API/hooks/dimensions.stories.tsx
================================================
import React from 'react';
import {
  ComposedChart,
  Legend,
  Line,
  ResponsiveContainer,
  XAxis,
  YAxis,
  useChartHeight,
  useChartWidth,
} from '../../../../src';
import { SvgDimensionShower } from '../../../ChartSizeDimensions';
import { pageData } from '../../data';

export default {
  docs: {
    autodocs: false,
  },
  /**
   * Without this piece of configuration, the createPortal makes Storybook throw an error.
   * See https://github.com/storybookjs/storybook/issues/18269#issuecomment-1711293995
   */
  parameters: {
    docs: {
      source: { type: 'code' },
    },
  },
};

export const WithAxesAndLegendAndResponsive = {
  render: (args: Record<string, any>) => {
    const ChartSizeDimensions = () => {
      const width = useChartWidth();
      const height = useChartHeight();
      return <SvgDimensionShower width={width} height={height} />;
    };

    return (
      <ResponsiveContainer {...args}>
        <ComposedChart data={pageData}>
          <ChartSizeDimensions />
          <Line dataKey="pv" />
          <XAxis dataKey="name" />
          <YAxis />
          <Legend />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    width: '100%',
    height: 400,
  },
};

export const WithResponsiveContainer = {
  render: (args: Record<string, any>) => {
    const ChartSizeDimensions = () => {
      const width = useChartWidth();
      const height = useChartHeight();
      return <SvgDimensionShower width={width} height={height} />;
    };

    return (
      <ResponsiveContainer {...args}>
        <ComposedChart>
          <ChartSizeDimensions />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    width: '100%',
    height: 400,
  },
};

export const WithStaticDimensions = {
  render: (args: Record<string, any>) => {
    const ChartSizeDimensions = () => {
      const width = useChartWidth();
      const height = useChartHeight();
      return <SvgDimensionShower width={width} height={height} />;
    };

    return (
      <ComposedChart {...args}>
        <ChartSizeDimensions />
      </ComposedChart>
    );
  },
  args: {
    width: 500,
    height: 500,
  },
};

export const WhenOutsideOfChart = {
  render: () => {
    return (
      <div>
        <p>
          This is outside of a chart so the hooks both return <code>undefined</code>
        </p>
        <p>
          useChartWidth: <code>{String(useChartWidth())}</code>
        </p>
        <p>
          useChartHeight: <code>{String(useChartHeight())}</code>
        </p>
      </div>
    );
  },
};



================================================
FILE: storybook/stories/API/polar/Pie.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Pie.stories';

# Pie

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component

The Pie can be used within a `<PieChart/>`.

## Child component

The Pie can be used with the following child components: `<Cell/>` `<LabelList/>`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/polar/Pie.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { pageData } from '../../data';
import { Pie, PieChart } from '../../../../src';
import { EventHandlers } from '../props/EventHandlers';
import { AnimationProps } from '../props/AnimationProps';
import { ActiveShapeProps } from '../props/ActiveShapeProps';

const GeneralProps: Args = {
  cx: {
    description: `The x-coordinate of center. If set a percentage,
      the final value is obtained by multiplying the percentage of container width.`,
    table: {
      type: { summary: 'percentage | number', defaultValue: '50%' },
      category: 'General',
    },
  },
  cy: {
    description: `The y-coordinate of center. If set a percentage,
      the final value is obtained by multiplying the percentage of container height.`,
    table: {
      type: { summary: 'percentage | number', defaultValue: '50%' },
      category: 'General',
    },
  },
  innerRadius: {
    description: `The inner radius of all the sectors. If set a percentage, the final value is
      obtained by multiplying the percentage of maxRadius which is calculated by the width, height, cx, cy.`,
    table: {
      type: { summary: 'percentage | number', defaultValue: 0 },
      category: 'General',
    },
  },
  outerRadius: {
    description: `The outer radius of all the sectors. If set a percentage, the final value is
      obtained by multiplying the percentage of maxRadius which is calculated by the width, height, cx, cy.
      If set a function, the function will be called to return customized radius.`,
    table: {
      type: { summary: 'percentage | number | Function', defaultValue: '80%' },
      category: 'General',
    },
  },
  startAngle: {
    description: 'The start angle of first sector.',
    table: {
      type: { summary: 'number', defaultValue: 0 },
      category: 'General',
    },
  },
  endAngle: {
    description: 'The end angle of last sector, which should be unequal to startAngle.',
    table: {
      type: { summary: 'number', defaultValue: 360 },
      category: 'General',
    },
  },
  minAngle: {
    description: 'The minimum angle of each nonzero data.',
    table: {
      type: { summary: 'number', defaultValue: 0 },
      category: 'General',
    },
  },
  paddingAngle: {
    description: 'The angle between two sectors.',
    table: {
      type: { summary: 'number', defaultValue: 0 },
      category: 'General',
    },
  },
  nameKey: {
    description: "The key of each sector's name.",
    table: { type: { summary: 'string', defaultValue: 'name' }, category: 'General' },
  },
  dataKey: {
    description: "The key of each sector's value.",
    table: { type: { summary: 'string | number | Function' }, category: 'General' },
  },
  legendType: {
    description: 'The type of icon in legend. If set to "none", no legend item will be rendered.',
    table: {
      type: {
        summary: `'line' | 'plainline' | 'square' | 'rect'| 'circle' | 'cross' | 'diamond' | 'square'
          | 'star' | 'triangle' | 'wye' | 'none'`,
        defaultValue: 'rect',
      },
      category: 'General',
    },
  },
  label: {
    description: `If false set, labels will not be drawn. If true set, labels will be drawn which have
      the props calculated internally. If object set, labels will be drawn which have the props
      merged by the internal calculated props and the option. If ReactElement set, the option
      can be the custom label element. If set a function, the function will be called to render
      customized label.`,
    table: {
      type: { summary: 'Boolean | Object | ReactElement | Function', defaultValue: false },
      category: 'General',
    },
  },
  labelLine: {
    description: `If false set, label lines will not be drawn. If true set, label lines will be drawn which
      have the props calculated internally. If object set, label lines will be drawn which have
      the props merged by the internal calculated props and the option. If ReactElement set,
      the option can be the custom label line element. If set a function, the function will be
      called to render customized label line.`,
    table: {
      type: { summary: 'Boolean | Object | ReactElement | Function', defaultValue: false },
      category: 'General',
    },
  },
  data: {
    description: 'The source data which each element is an object.',
    table: { type: { summary: 'Array' }, category: 'General' },
  },
  activeIndex: ActiveShapeProps.activeIndex,
  activeShape: ActiveShapeProps.activeShape,
  inactiveShape: {
    description: 'The shape of inactive sector.',
    table: { type: { summary: 'Object | ReactElement | Function' }, category: 'General' },
  },
  rootTabIndex: {
    description: 'The tabIndex of the root layer of the Pie component.',
    table: {
      type: { summary: 'number', defaultValue: 0 },
      category: 'General',
    },
  },
};

export default {
  argTypes: {
    ...GeneralProps,
    ...EventHandlers,
    ...AnimationProps,
    // Deprecated
    dangerouslySetInnerHTML: { table: { category: 'Deprecated' }, hide: true, disable: true },
  },
  component: Pie,
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <PieChart width={300} height={300}>
        <Pie dataKey="uv" {...args} />
      </PieChart>
    );
  },
  args: {
    data: pageData,
    dataKey: 'uv',
    nameKey: 'name',
  },
};



================================================
FILE: storybook/stories/API/polar/PolarAngleAxis.mdx
================================================
import { ArgTypes, Meta, Story, Canvas, } from '@storybook/blocks';
import * as PolarAngleAxisStories from './PolarAngleAxis.stories';

# PolarAngleAxis
<Meta of={PolarAngleAxisStories} />

<Canvas>
  <Story name="API" of={PolarAngleAxisStories} />
</Canvas>
## Parent Component

The PolarAngleAxis can be used within a `<RadarChart />` or `<RadialBarChart />`.

## Child component

The PolarAngleAxis can be used with the following child components: `<Label />`

## Properties

<ArgTypes of={PolarAngleAxisStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/polar/PolarAngleAxis.stories.tsx
================================================
import React from 'react';
import { PolarAngleAxis, RadialBarChart } from '../../../../src';
import { EventHandlers } from '../props/EventHandlers';
import { pageData } from '../../data';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { StorybookArgs } from '../../../StorybookArgs';

const GeneralProps: StorybookArgs = {
  type: {
    description: 'The type of axis.',
    options: ['number', 'category'],
    control: 'radio',
    table: { type: { summary: 'number | category' }, defaultValue: 'category', category: 'General' },
  },
  allowDuplicatedCategory: {
    description: 'Allow the axis that has duplicated category or not when the type of axis is "category".',
    table: { type: { summary: 'boolean' }, category: 'General' },
    defaultValue: true,
  },
  domain: {
    description: `Specify the domain of radius in a polar chart.
      And the length should be 2. And each element in the array
      can be a number, 'auto', 'dataMin' or 'dataMax'.
      If any element of domain is set to be 'auto',
      comprehensible scale ticks will be calculated,
      and the final domain of axis is generated by the ticks.
      If a function, receives '[dataMin, dataMax]', and must return a computed domain as '[min, max]'.s`,
    table: { type: { summary: 'Array | Function' }, category: 'General' },
    defaultValue: [0, 'auto'],
  },
  reversed: {
    description: 'If set to true, the ticks of this axis are reversed.',
    table: { type: { summary: 'boolean' }, defaultValue: false, category: 'General' },
  },
  orientation: {
    description: 'The orientation of axis text.',
    table: { type: { summary: 'inner | outer' }, defaultValue: 'outer', category: 'General' },
  },
  axisLine: {
    description: `If false set, axis line will not be drawn.
    If true set, axis line will be drawn which have the props calculated internally.
    If object set, axis line will be drawn which have the props merged by the internal calculated props and the option.`,
    control: 'boolean',
    table: { type: { summary: 'boolean | Object' }, defaultValue: true, category: 'General' },
  },
  tick: {
    description: `If false set, ticks will not be drawn. If true set,
    ticks will be drawn which have the props calculated internally.
    If object set, ticks will be drawn which have the props mergered by the internal calculated props and the option.
    If ReactElement set, the option can be the custom tick element. If set a function, the function will be called to render customized ticks.`,
    control: 'boolean',
    table: { type: { summary: 'boolean | Object | Element | Function' }, defaultValue: true, category: 'General' },
  },
  tickFormatter: {
    description: 'The function to formatting tick.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  scale: {
    description: 'The function to formatting tick.',
    options: ['auto', 'linear', 'pow', 'sqrt', 'log', 'identity', 'point'],
    control: 'select',
    table: {
      type: {
        summary: `auto | linear | pow | sqrt | log | identity
          | time | band | point | ordinal | quantile | quantize | utc | sequential | threshold | Function`,
      },
      category: 'General',
      defaultValue: 'auto',
    },
  },
};

export default {
  argTypes: {
    ...GeneralProps,
    ...EventHandlers,
  },
  component: PolarAngleAxis,
};
const [surfaceWidth, surfaceHeight] = [600, 300];

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <RadialBarChart width={surfaceWidth} height={surfaceHeight} data={pageData}>
        <PolarAngleAxis {...args} />
      </RadialBarChart>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    axisLineType: 'polygon',
    stroke: 'green',
    dataKey: 'uv',
    type: 'number',
  },
};



================================================
FILE: storybook/stories/API/polar/PolarGrid.mdx
================================================
import { ArgTypes } from '@storybook/blocks';
import * as PolarGridStories from './PolarGrid.stories';

# PolarGrid

## Parent Component

The PolarGrid can be used within a `<RadarChart />` or a `<RadialBarChart />`.

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={PolarGridStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/polar/PolarGrid.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { PolarGrid, ResponsiveContainer, Surface } from '../../../../src';

const GeneralProps: Args = {
  cx: {
    description: 'The x-coordinate of center.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  cy: {
    description: 'The y-coordinate of center.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  innerRadius: {
    description: 'The radius of the inner polar grid.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  outerRadius: {
    description: 'The radius of the outer polar grid.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  polarAngles: {
    description: "The array of every line grid's angle.",
    table: { type: { summary: 'Array' }, category: 'General' },
  },
  polarRadius: {
    description: "The array of every circle grid's radius",
    table: { type: { summary: 'Array' }, category: 'General' },
  },
  gridType: {
    description: 'The type of polar grids.',
    table: { type: { summary: "'polygon' | 'circle'", defaultValue: 'polygon' }, category: 'General' },
  },
  radialLines: {
    description: 'Whether to display radial lines.',
    table: { type: { summary: 'boolean', defaultValue: true }, category: 'General' },
  },
};

export default {
  argTypes: {
    ...GeneralProps,
  },
  component: PolarGrid,
};

const [surfaceWidth, surfaceHeight] = [500, 500];

export const Simple = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <Surface
          width={surfaceWidth}
          height={surfaceHeight}
          viewBox={{
            x: 0,
            y: 0,
            width: surfaceWidth,
            height: surfaceHeight,
          }}
        >
          <PolarGrid cx={250} cy={250} innerRadius={0} outerRadius={200} {...args} />
        </Surface>
      </ResponsiveContainer>
    );
  },
  args: {
    polarAngles: [0, 30, 60, 90, 145, 180, 200, 270, 300],
    polarRadius: [10, 20, 40, 80],
  },
};



================================================
FILE: storybook/stories/API/polar/PolarRadiusAxis.mdx
================================================
import { ArgTypes, Meta, Story, Canvas, } from '@storybook/blocks';
import * as PolarRadiusAxisStories from './PolarRadiusAxis.stories';

# PolarRadiusAxis
<Meta of={PolarRadiusAxisStories} />

<Canvas>
  <Story name="API" of={PolarRadiusAxisStories} />
</Canvas>
## Parent Component

The PolarRadiusAxis can be used within a `<RadarChart />` or `<RadialBarChart />`.

## Child component

The PolarRadiusAxis can be used with the following child components: `<Label />`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={PolarRadiusAxisStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/polar/PolarRadiusAxis.stories.tsx
================================================
import React from 'react';
import { Label, PolarRadiusAxis, RadarChart, ResponsiveContainer } from '../../../../src';
import { EventHandlers } from '../props/EventHandlers';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { StorybookArgs } from '../../../StorybookArgs';
import { pageData } from '../../data';

const GeneralProps: StorybookArgs = {
  angle: {
    description: 'The angle of radial direction line to display axis text.',
    table: {
      type: { summary: 'number' },
      defaultValue: 0,
      category: 'General',
    },
  },
  type: {
    description: 'The type of axis.',
    options: ['number', 'category'],
    control: 'radio',
    table: {
      type: { summary: 'number | category' },
      defaultValue: 'number',
      category: 'General',
    },
  },
  allowDuplicatedCategory: {
    description: 'Allow the axis that has duplicated category or not when the type of axis is "category".',
    table: { type: { summary: 'Boolean' }, defaultValue: true, category: 'General' },
  },
  domain: {
    description: `Specify the domain of radius in a polar chart.
      And the length should be 2. And each element in the array
      can be a number, 'auto', 'dataMin' or 'dataMax'.
      If any element of domain is set to be 'auto',
      comprehensible scale ticks will be calculated,
      and the final domain of axis is generated by the ticks.
      If a function, receives '[dataMin, dataMax]', and must return a computed domain as '[min, max]'.s`,
    table: { type: { summary: 'Array | Function' }, defaultValue: [0, 'auto'], category: 'General' },
  },
  reversed: {
    description: 'If set to true, the ticks of this axis are reversed.',
    table: { type: { summary: 'boolean' }, defaultValue: false, category: 'General' },
  },
  label: {
    description: `If set a string or a number, default label will be drawn,
        and the option is content. If set a React element,
        the option is the custom react element of drawing label.
        If set a function, the function will be called to render customized label.`,
    control: 'text',
    table: { type: { summary: 'String | Number | ReactElement | Function' }, category: 'General' },
  },
  orientation: {
    description: 'The orientation of axis text.',
    table: { type: { summary: 'left | right | middle' }, defaultValue: 'right', category: 'General' },
  },
  axisLine: {
    description: `If false set, axis line will not be drawn.
    If true set, axis line will be drawn which have the props calculated internally.
    If object set, axis line will be drawn which have the props merged by the internal calculated props and the option.`,
    table: { type: { summary: 'boolean | Object' }, defaultValue: true, category: 'General' },
  },
  tick: {
    description: `If false set, ticks will not be drawn. If true set,
    ticks will be drawn which have the props calculated internally.
    If object set, ticks will be drawn which have the props merged by the internal calculated props and the option.
    If ReactElement set, the option can be the custom tick element. If set a function, the function will be called to render customized ticks.`,
    table: { type: { summary: 'Bool | Object | Element | Function' }, defaultValue: true, category: 'General' },
  },
  tickFormatter: {
    description: 'The function to formatting tick.',
    table: { type: { summary: 'number' }, category: 'General' },
  },
  tickCount: {
    description: `The count of axis ticks. Not used if 'type' is 'category'.`,
    table: { type: { summary: 'number' }, defaultValue: 5, category: 'General' },
  },
  stroke: {
    description: 'Color of axisLine and text.',
    control: 'color',
    table: {
      type: {
        summary: 'CSS color',
      },
      defaultValue: '#ccc',
      category: 'General',
    },
  },
};

export default {
  argTypes: {
    ...GeneralProps,
    ...EventHandlers,
  },
  component: PolarRadiusAxis,
};
const [surfaceWidth, surfaceHeight] = [600, 300];

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={surfaceHeight}>
        <RadarChart width={surfaceWidth} height={surfaceHeight} data={pageData}>
          <PolarRadiusAxis {...args}>
            <Label position="outside" offset={20}>
              PolarRadiusAxis
            </Label>
          </PolarRadiusAxis>
        </RadarChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    angle: 30,
    dataKey: 'uv',
    type: 'category',
  },
};



================================================
FILE: storybook/stories/API/polar/Radar.mdx
================================================
import { ArgTypes } from '@storybook/blocks';
import * as RadarStories from './Radar.stories';

# Radar

## Parent Component

The Radar can be used within a `<RadarChart/>`.

## Child component

The Radar can be used with the following child components: `<LabelList/>`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<ArgTypes of={RadarStories} sort={'requiredFirst'} />



================================================
FILE: storybook/stories/API/polar/Radar.stories.tsx
================================================
import React from 'react';
import { Args } from '@storybook/react';
import { Radar, RadarChart, PolarGrid, PolarAngleAxis, PolarRadiusAxis, ResponsiveContainer } from '../../../../src';
import { subjectData } from '../../data';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { AnimationProps } from '../props/AnimationProps';
import { legendType } from '../props/Legend';

const GeneralProps: Args = {
  dataKey: {
    description: 'The key of a group of data which should be unique in a radar chart.',
    table: { type: { summary: 'string | number | Function' }, category: 'General' },
  },
  points: {
    description: 'The coordinates of all the vertexes of the radar shape, like [{ x, y }].',
    table: { type: { summary: 'Array' }, category: 'General' },
  },
  dot: {
    description: `If false set, dots will not be drawn. If true set, dots will be drawn which have
    the props calculated internally. If object set, dots will be drawn which have the props merged
    by the internal calculated props and the option. If ReactElement set, the option can be the custom dot element.
    If set a function, the function will be called to render customized dot.`,
    table: { type: { summary: 'Bool | Object | Element | Function' }, category: 'General' },
  },
};

const LabelProps: Args = {
  label: {
    description: `If set a string or a number, default label will be drawn, and the option is content.
    If set a React element, the option is the custom react element of drawing label. If set a function,
    the function will be called to render customized label.`,
    table: { type: { summary: 'string | number | ReactElement | Function' }, category: 'Label' },
  },
};

const StyleProps: Args = {
  shape: {
    description: `If set a ReactElement, the shape of dot can be customized. If set a function,
    the function will be called to render customized shape.`,
    table: {
      type: {
        summary: 'ReactElement | Function',
      },
      category: 'Style',
    },
  },
};

export default {
  argTypes: {
    ...AnimationProps,
    ...GeneralProps,
    ...LabelProps,
    ...StyleProps,
    legendType,
  },
  component: Radar,
};

export const General = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={500}>
        <RadarChart
          cx="50%"
          cy="50%"
          outerRadius="80%"
          data={subjectData}
          margin={{
            top: 5,
            right: 30,
            left: 20,
            bottom: 5,
          }}
        >
          <PolarGrid />
          <PolarAngleAxis dataKey="subject" />
          <PolarRadiusAxis />
          <Radar {...args} />
        </RadarChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(GeneralProps),
    dataKey: 'A',
    name: 'Mike',
    stroke: '#8884d8',
    fill: '#8884d8',
    fillOpacity: 0.6,
  },
  parameters: {
    controls: { include: Object.keys(GeneralProps) },
  },
};



================================================
FILE: storybook/stories/API/polar/RadialBar.mdx
================================================
import { Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './RadialBar.stories';

# RadialBar

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Parent Component

The RadialBar can be used within a `<RadialBarChart />`.

## Child component

The RadialBar can be used with the following child components: `<Cell />` `<LabelList />`

## Properties

Properties in the groups Other and Internal are not recommended to be used.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/polar/RadialBar.stories.tsx
================================================
import React from 'react';
import { pageDataWithFillColor } from '../../data';
import { Legend, PolarAngleAxis, RadialBar, RadialBarChart, ResponsiveContainer, Tooltip } from '../../../../src';
import { getStoryArgsFromArgsTypesObject } from '../props/utils';
import { RadialBarProps } from '../props/RadialBarProps';

export default {
  argTypes: RadialBarProps,
  component: RadialBar,
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={400}>
        <RadialBarChart width={400} height={400} data={pageDataWithFillColor}>
          <Legend />
          <PolarAngleAxis />
          <RadialBar dataKey="uv" {...args} />
          <Tooltip />
        </RadialBarChart>
      </ResponsiveContainer>
    );
  },
  args: {
    ...getStoryArgsFromArgsTypesObject(RadialBarProps),
    legendType: 'circle',
    label: { fill: '#333', fontSize: 15, position: 'insideStart' },
    background: true,
    isAnimationActive: true,
    animationBegin: 50,
    animationDuration: 1000,
    animationEasing: 'ease',
    cornerRadius: 10,
    cornerIsExternal: true,
    tooltipType: 'responsive',
    maxBarSize: 15,
    minPointSize: 90,
  },
};



================================================
FILE: storybook/stories/API/props/ActiveShapeProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';

export const ActiveShapeProps: StorybookArgs = {
  activeIndex: {
    description:
      'The index of the individual shapes of the graph element to be marked as active, and render props.activeShape',
    table: {
      category: 'General',
    },
  },
  shape: {
    description: 'The customized shape to be rendered.',
    table: {
      type: {
        summary: 'Function | boolean | ReactElement | object',
      },
      defaultValue: undefined,
      category: 'General',
    },
  },
  activeShape: {
    description: 'The customized shape to be rendered if activeIndex or activeTooltipIndex match',
    table: {
      type: {
        summary: 'Function | boolean | ReactElement | object',
      },
      defaultValue: undefined,
      category: 'General',
    },
  },
};



================================================
FILE: storybook/stories/API/props/AnimationProps.ts
================================================
/*
 * This file both exports the documentation of shared props separately, to be reused in places where only single props
 * are documented, as well as grouped in case a whole group is needed.
 */
import { StorybookArg, StorybookArgs } from '../../../StorybookArgs';

export const animateNewValues: StorybookArg = { table: { category: 'Animation' } };
export const animationBegin: StorybookArg = {
  description: 'Specifies when the animation should begin, the unit of this option is ms.',
  type: { name: 'number' },
  defaultValue: 0,
  table: {
    defaultValue: { summary: '0' },
    category: 'Animation',
  },
};
export const animationDuration: StorybookArg = {
  table: {
    category: 'Animation',
  },
};
export const animationEasing: StorybookArg = {
  table: {
    category: 'Animation',
  },
};

export const isAnimationActive: StorybookArg = {
  description: 'If set false, animation of component will be disabled.',
  table: {
    type: { summary: 'boolean' },
    defaultValue: { summary: 'true in CSR, and false in SSR' },
    category: 'Animation',
  },
  defaultValue: true,
};

/**
 * Caveat: If any prop is added here, it would falsely be add to the documentation of the component where this group
 * is used. If the group is to be extended, then only single props should be imported by each component that does not
 * use all of them.
 * */
export const AnimationProps: StorybookArgs = {
  animationBegin,
  animationEasing,
  animationDuration,
  isAnimationActive,
};



================================================
FILE: storybook/stories/API/props/AreaChartProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';
import { CartesianChartProps } from './CartesianChartProps';

export const AreaChartProps: StorybookArgs = {
  ...CartesianChartProps,
  baseValue: {
    description: 'The base value of area.',
    table: {
      type: {
        summary: "number | 'dataMin' | 'dataMax' | 'auto'",
      },
      defaultValue: 'auto',
      category: 'Area',
    },
  },
};



================================================
FILE: storybook/stories/API/props/BarChartProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';
import { CategoricalChartProps } from './ChartProps';

export const BarChartProps: StorybookArgs = {
  ...CategoricalChartProps,
  barCategoryGap: {
    description: 'The gap between two bar categories, which can be a percent value or a fixed value.',
    table: {
      type: {
        summary: 'Percentage | number',
      },
      defaultValue: '10%',
      category: 'Bar',
    },
  },
  barGap: {
    description: 'The gap between two bars in the same category.',
    table: {
      type: {
        summary: 'number',
      },
      defaultValue: 4,
      category: 'Bar',
    },
  },
  barSize: {
    description: `The width or height of each bar. If the barSize is not specified, the size of the bar
      will be calculated by the barCategoryGap, barGap and the quantity of bar groups.`,
    control: {
      type: 'number',
    },
    table: {
      type: {
        summary: 'number | Percentage',
      },
      category: 'Bar',
    },
  },
  maxBarSize: {
    description: 'The maximum size of bar.',
    control: {
      type: 'number',
    },
    table: {
      type: {
        summary: 'number',
      },
      category: 'Bar',
    },
  },
};



================================================
FILE: storybook/stories/API/props/CartesianChartProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';
import { CategoricalChartProps } from './ChartProps';

export const CartesianChartProps: StorybookArgs = {
  ...CategoricalChartProps,
  layout: {
    description: 'The layout of areas, bars, lines in the chart.',
    options: ['horizontal', 'vertical'],
    control: {
      type: 'radio',
    },
    table: {
      type: {
        summary: 'horizontal | vertical',
      },
      defaultValue: 'horizontal',
      category: 'General',
    },
  },
  stackOffset: {
    description: `Determines how values are stacked:

- \`none\` is the default, it adds values on top of each other. No smarts. Negative values will overlap.
- \`expand\` make it so that the values always add up to 1 - so the chart will look like a rectangle.
- \`wiggle\` and \`silhouette\` tries to keep the chart centered.
- \`sign\` stacks positive values above zero and negative values below zero. Similar to \`none\` but handles negatives.
- \`positive\` ignores all negative values, and then behaves like \`none\`.

Also see https://d3js.org/d3-shape/stack#stack-offsets
(note that the \`diverging\` offset in d3 is named \`sign\` in recharts)
`,
    options: ['sign', 'expand', 'none', 'wiggle', 'silhouette', 'positive'],
    control: {
      type: 'radio',
    },
    table: {
      type: {
        summary: 'expand | none | wiggle | silhouette | sign | positive',
      },
      defaultValue: 'none',
      category: 'General',
    },
  },
};



================================================
FILE: storybook/stories/API/props/CartesianComponentShared.ts
================================================
import { StorybookArg, StorybookArgs } from '../../../StorybookArgs';

export const dataKey: StorybookArg = {
  description: `The key or getter of a group of data.
      It could be an accessor function such as (row)=>value`,
  table: {
    type: { summary: 'string | number | function' },
    category: 'General',
  },
};

export const nameKey: StorybookArg = {
  description: "The key of each sector's name.",
  table: {
    type: { summary: 'String' },
    category: 'General',
  },
};

export const activeShape: StorybookArg = {
  description: '',
  table: {
    type: {
      summary: 'Object | ReactElement | Function | boolean',
    },
    category: 'General',
  },
};

export const xAxisId: StorybookArg = {
  description: 'The id of x-axis which is corresponding to the data.',
  table: { type: { summary: 'string | number' }, category: 'General' },
};
export const yAxisId: StorybookArg = {
  description: 'The id of y-axis which is corresponding to the data.',
  table: { type: { summary: 'string | number' }, category: 'General' },
};
export const zAxisId: StorybookArg = {
  description: 'The id of z-axis which is corresponding to the data.',
  table: { type: { summary: 'string | number' }, category: 'General' },
};

export const General: StorybookArgs = {
  dataKey,
  id: {
    description: `The unique id of this component, which will be used to generate unique clip path id internally.
      This props is suggested to be set in SSR.`,
    type: { name: 'string' },
    table: { category: 'General' },
  },
  name: {
    description: `The name of data. This option will be used in tooltip and legend to represent a line.
    If no value was set to this option, the value of dataKey will be used alternatively.`,
    table: {
      type: { summary: 'string | number' },
      category: 'General',
    },
  },
  unit: {
    table: {
      type: { summary: 'string | number' },
      category: 'General',
    },
  },
  xAxisId,
  yAxisId,
};

export const data: StorybookArg = {
  description: `The source data, in which each element is an object.
    This can be defined either on the chart element (ScatterChart, LineChart, etc) or on the graphical item (Scatter, Line).
    The object shape is flexible, with no pre-defined properties;
    The dataKey props then define which properties from this object render where.`,
  table: {
    category: 'General',
    type: {
      summary: 'array of objects',
    },
  },
};

export const layout: StorybookArg = {
  description: 'The layout of line, usually inherited from parent.',
  table: {
    type: {
      summary: 'horizontal | vertical',
    },
    category: 'Internal',
  },
};



================================================
FILE: storybook/stories/API/props/ChartProps.ts
================================================
import { onClick, onMouseDown, onMouseEnter, onMouseLeave, onMouseMove, onMouseUp } from './EventHandlers';
import { StorybookArg, StorybookArgs } from '../../../StorybookArgs';

export const data: StorybookArg = {
  description: 'The source data, in which each element is an object.',
  table: {
    type: {
      summary: 'Array',
    },
    category: 'General',
  },
};

export const ChartSizeProps: StorybookArgs = {
  height: {
    description: 'The height of chart container.',
    control: {
      type: 'number',
    },
    table: {
      type: {
        summary: 'number',
      },
      category: 'General',
    },
  },
  width: {
    description: 'The width of chart container.',
    control: {
      type: 'number',
    },
    table: {
      type: {
        summary: 'number',
      },
      category: 'General',
    },
  },
};

export const margin = {
  description: 'The sizes of whitespace around the container.',
  table: {
    type: {
      summary: 'Object',
    },
    defaultValue: { top: 5, right: 5, bottom: 5, left: 5 },
    category: 'General',
  },
};

export const dataKey = {
  description: 'The key or getter of a group of data which should be unique in a chart.',
  table: {
    type: {
      summary: 'string | number | Function',
    },
    category: 'General',
  },
};

// These props are shared between the following charts:
// - AreaChart
// - BarChart
// - ComposedChart
// - LineChart
// - PieChart
// - RadarChart
// - RadialBarChart
// - ScatterChart
// - FunnelChart
export const CategoricalChartProps: StorybookArgs = {
  ...ChartSizeProps,
  dataKey: {
    description: `Can be used to mirror dataKey used on children components, using it as this level will force
the chart to animate between two states even though the data array stays the same. Useful to animate when
toggling between multiple dataKey.`,
    table: {
      type: {
        summary: 'string | number | function | undefined',
      },
      category: 'General',
    },
  },
  data,
  margin,
  accessibilityLayer: {
    description: 'Turn on accessibility support for keyboard-only and screen reader users.',
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: true,
      category: 'General',
    },
  },
  role: {
    description: 'The ARIA role for the chart, which provides semantic information for screen reader users.',
    table: {
      type: {
        summary: 'String | undefined',
      },
      defaultValue: undefined,
      category: 'General',
    },
  },
  tabIndex: {
    description: 'If and where the chart should appear in the tab order',
    table: {
      type: {
        summary: 'number | undefined',
      },
      defaultValue: undefined,
      category: 'General',
    },
  },
  style: {
    description: 'The style of chart.',
    table: {
      type: {
        summary: 'Object',
      },
      category: 'General',
    },
  },
  desc: {
    description: 'The description of chart.',
    table: {
      type: {
        summary: 'String',
      },
      category: 'General',
    },
  },
  className: {
    table: {
      category: 'Internal',
    },
  },
  defaultShowTooltip: {
    description: 'If true set, the tooltip will be displayed when the chart is rendered.',
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: false,
      category: 'General',
    },
  },
  id: {
    description: 'The unique id of chart.',
    table: {
      type: {
        summary: 'String',
      },
      category: 'General',
    },
  },
  onClick,
  onMouseDown,
  onMouseEnter,
  onMouseLeave,
  onMouseMove,
  onMouseUp,
  reverseStackOrder: {
    description: `If \`false\`, stacked items will be rendered left to right. If \`true\`, stacked items
      will be rendered right to left. (Render direction affects SVG layering, not x position.)`,
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: false,
      category: 'General',
    },
  },
  syncId: {
    description: `If any two categorical charts(LineChart, AreaChart, BarChart, ComposedChart) have the same syncId,
      these two charts can sync the position tooltip, and the startIndex, endIndex of Brush.`,
    control: {
      type: 'text',
    },
    table: {
      type: {
        summary: 'String',
      },
      category: 'General',
    },
  },
  syncMethod: {
    description: `When syncId is provided, allows customization of how the charts will synchronize tooltips and
    brushes. Using 'index' (default setting), other charts will reuse current datum's index within the data array.
    In cases where data does not have the same length, this might yield unexpected results. In that case use 'value'
    which will try to match other charts values, or a fully custom function which will receive tick, data as argument
    and should return an index.`,
    control: {
      type: 'radio',
    },
    options: ['index', 'value'],
    defaultValue: 'index',
    table: {
      type: {
        summary: "'index' | 'value' | function",
      },
      defaultValue: "'index'",
      category: 'General',
    },
  },
  throttleDelay: {
    description: `The delay of throttle for mouse events, which can be used to avoid
      the performance problem when the chart is rendered in a heavy environment.`,
    table: {
      type: {
        summary: 'Number',
      },
      category: 'General',
    },
  },
  title: {
    description: 'The title of chart.',
    control: {
      type: 'text',
    },
    table: {
      type: {
        summary: 'String',
      },
      category: 'General',
    },
  },
};



================================================
FILE: storybook/stories/API/props/DotProps.ts
================================================
/*
 * This file both exports the documentation of shared props separately, to be reused in places where only single props
 * are documented, as well as grouped in case a whole group is needed.
 */
import { StorybookArg, StorybookArgs } from '../../../StorybookArgs';

export const r: StorybookArg = {
  description: 'The radius of the dot.',
  control: { type: 'number' },
  table: {
    type: { summary: 'number' },
    defaultValue: { summary: 10 },
    category: 'General',
  },
  defaultValue: 10,
};

export const cx: StorybookArg = {
  description: 'The x-coordinate of the dots center.',
  table: {
    type: { summary: 'number' },
    category: 'General',
  },
};

export const cy: StorybookArg = {
  description: 'The y-coordinate of the dots center.',
  table: {
    type: { summary: 'number' },
    category: 'General',
  },
};

/**
 * Caveat: If any prop is added here, it would falsely be add to the documentation of the component where this group
 * is used. If the group is to be extended, then only single props should be imported by each component that does not
 * use all of them.
 * */
export const DotProps: StorybookArgs = {
  r,
  cx,
  cy,
};



================================================
FILE: storybook/stories/API/props/EventHandlers.ts
================================================
/*
 * This file both exports the documentation of shared props separately, to be reused in places where only single props
 * are documented, as well as grouped in case a whole group is needed.
 */

import { StorybookArgs } from '../../../StorybookArgs';

export const onAbort = { table: { category: 'EventHandlers' } };
export const onAbortCapture = { table: { category: 'EventHandlers' } };
export const onAnimationEnd = {
  table: {
    category: 'EventHandlers',
    description: 'The customized event handler of animation end',
  },
};
export const onAnimationEndCapture = { table: { category: 'EventHandlers' } };
export const onAnimationIteration = { table: { category: 'EventHandlers' } };
export const onAnimationIterationCapture = { table: { category: 'EventHandlers' } };
export const onAnimationStart = {
  table: {
    description: 'The customized event handler of animation start',
    category: 'EventHandlers',
  },
};
export const onAnimationStartCapture = { table: { category: 'EventHandlers' } };
export const onAuxClick = { table: { category: 'EventHandlers' } };
export const onAuxClickCapture = { table: { category: 'EventHandlers' } };
export const onBeforeInput = { table: { category: 'EventHandlers' } };
export const onBeforeInputCapture = { table: { category: 'EventHandlers' } };
export const onBlur = { table: { category: 'EventHandlers' } };
export const onBlurCapture = { table: { category: 'EventHandlers' } };
export const onCanPlay = { table: { category: 'EventHandlers' } };
export const onCanPlayCapture = { table: { category: 'EventHandlers' } };
export const onCanPlayThrough = { table: { category: 'EventHandlers' } };
export const onCanPlayThroughCapture = { table: { category: 'EventHandlers' } };
export const onChange = { table: { category: 'EventHandlers' } };
export const onChangeCapture = { table: { category: 'EventHandlers' } };
export const onClick = { table: { category: 'EventHandlers' } };
export const onClickCapture = { table: { category: 'EventHandlers' } };
export const onCompositionEnd = { table: { category: 'EventHandlers' } };
export const onCompositionEndCapture = { table: { category: 'EventHandlers' } };
export const onCompositionStart = { table: { category: 'EventHandlers' } };
export const onCompositionStartCapture = { table: { category: 'EventHandlers' } };
export const onCompositionUpdate = { table: { category: 'EventHandlers' } };
export const onCompositionUpdateCapture = { table: { category: 'EventHandlers' } };
export const onContextMenu = { table: { category: 'EventHandlers' } };
export const onContextMenuCapture = { table: { category: 'EventHandlers' } };
export const onCopy = { table: { category: 'EventHandlers' } };
export const onCopyCapture = { table: { category: 'EventHandlers' } };
export const onCut = { table: { category: 'EventHandlers' } };
export const onCutCapture = { table: { category: 'EventHandlers' } };
export const onDoubleClick = { table: { category: 'EventHandlers' } };
export const onDoubleClickCapture = { table: { category: 'EventHandlers' } };
export const onDrag = { table: { category: 'EventHandlers' } };
export const onDragCapture = { table: { category: 'EventHandlers' } };
export const onDragEnd = { table: { category: 'EventHandlers' } };
export const onDragEndCapture = { table: { category: 'EventHandlers' } };
export const onDragEnter = { table: { category: 'EventHandlers' } };
export const onDragEnterCapture = { table: { category: 'EventHandlers' } };
export const onDragExit = { table: { category: 'EventHandlers' } };
export const onDragExitCapture = { table: { category: 'EventHandlers' } };
export const onDragLeave = { table: { category: 'EventHandlers' } };
export const onDragLeaveCapture = { table: { category: 'EventHandlers' } };
export const onDragOver = { table: { category: 'EventHandlers' } };
export const onDragOverCapture = { table: { category: 'EventHandlers' } };
export const onDragStart = { table: { category: 'EventHandlers' } };
export const onDragStartCapture = { table: { category: 'EventHandlers' } };
export const onDrop = { table: { category: 'EventHandlers' } };
export const onDropCapture = { table: { category: 'EventHandlers' } };
export const onDurationChange = { table: { category: 'EventHandlers' } };
export const onDurationChangeCapture = { table: { category: 'EventHandlers' } };
export const onEmptied = { table: { category: 'EventHandlers' } };
export const onEmptiedCapture = { table: { category: 'EventHandlers' } };
export const onEncrypted = { table: { category: 'EventHandlers' } };
export const onEncryptedCapture = { table: { category: 'EventHandlers' } };
export const onEnded = { table: { category: 'EventHandlers' } };
export const onEndedCapture = { table: { category: 'EventHandlers' } };
export const onError = { table: { category: 'EventHandlers' } };
export const onErrorCapture = { table: { category: 'EventHandlers' } };
export const onFocus = { table: { category: 'EventHandlers' } };
export const onFocusCapture = { table: { category: 'EventHandlers' } };
export const onGotPointerCapture = { table: { category: 'EventHandlers' } };
export const onGotPointerCaptureCapture = { table: { category: 'EventHandlers' } };
export const onInput = { table: { category: 'EventHandlers' } };
export const onInputCapture = { table: { category: 'EventHandlers' } };
export const onInvalid = { table: { category: 'EventHandlers' } };
export const onInvalidCapture = { table: { category: 'EventHandlers' } };
export const onKeyDown = { table: { category: 'EventHandlers' } };
export const onKeyDownCapture = { table: { category: 'EventHandlers' } };
export const onKeyPress = { table: { category: 'EventHandlers' } };
export const onKeyPressCapture = { table: { category: 'EventHandlers' } };
export const onKeyUp = { table: { category: 'EventHandlers' } };
export const onKeyUpCapture = { table: { category: 'EventHandlers' } };
export const onLoad = { table: { category: 'EventHandlers' } };
export const onLoadCapture = { table: { category: 'EventHandlers' } };
export const onLoadStart = { table: { category: 'EventHandlers' } };
export const onLoadStartCapture = { table: { category: 'EventHandlers' } };
export const onLoadedData = { table: { category: 'EventHandlers' } };
export const onLoadedDataCapture = { table: { category: 'EventHandlers' } };
export const onLoadedMetadata = { table: { category: 'EventHandlers' } };
export const onLoadedMetadataCapture = { table: { category: 'EventHandlers' } };
export const onLostPointerCapture = { table: { category: 'EventHandlers' } };
export const onLostPointerCaptureCapture = { table: { category: 'EventHandlers' } };
export const onMouseDown = { table: { category: 'EventHandlers' } };
export const onMouseDownCapture = { table: { category: 'EventHandlers' } };
export const onMouseEnter = { table: { category: 'EventHandlers' } };
export const onMouseLeave = { table: { category: 'EventHandlers' } };
export const onMouseMove = { table: { category: 'EventHandlers' } };
export const onMouseMoveCapture = { table: { category: 'EventHandlers' } };
export const onMouseOut = { table: { category: 'EventHandlers' } };
export const onMouseOutCapture = { table: { category: 'EventHandlers' } };
export const onMouseOver = { table: { category: 'EventHandlers' } };
export const onMouseOverCapture = { table: { category: 'EventHandlers' } };
export const onMouseUp = { table: { category: 'EventHandlers' } };
export const onMouseUpCapture = { table: { category: 'EventHandlers' } };
export const onPaste = { table: { category: 'EventHandlers' } };
export const onPasteCapture = { table: { category: 'EventHandlers' } };
export const onPause = { table: { category: 'EventHandlers' } };
export const onPauseCapture = { table: { category: 'EventHandlers' } };
export const onPlay = { table: { category: 'EventHandlers' } };
export const onPlayCapture = { table: { category: 'EventHandlers' } };
export const onPlaying = { table: { category: 'EventHandlers' } };
export const onPlayingCapture = { table: { category: 'EventHandlers' } };
export const onPointerCancel = { table: { category: 'EventHandlers' } };
export const onPointerCancelCapture = { table: { category: 'EventHandlers' } };
export const onPointerDown = { table: { category: 'EventHandlers' } };
export const onPointerDownCapture = { table: { category: 'EventHandlers' } };
export const onPointerEnter = { table: { category: 'EventHandlers' } };
export const onPointerEnterCapture = { table: { category: 'EventHandlers' } };
export const onPointerLeave = { table: { category: 'EventHandlers' } };
export const onPointerLeaveCapture = { table: { category: 'EventHandlers' } };
export const onPointerMove = { table: { category: 'EventHandlers' } };
export const onPointerMoveCapture = { table: { category: 'EventHandlers' } };
export const onPointerOut = { table: { category: 'EventHandlers' } };
export const onPointerOutCapture = { table: { category: 'EventHandlers' } };
export const onPointerOver = { table: { category: 'EventHandlers' } };
export const onPointerOverCapture = { table: { category: 'EventHandlers' } };
export const onPointerUp = { table: { category: 'EventHandlers' } };
export const onPointerUpCapture = { table: { category: 'EventHandlers' } };
export const onProgress = { table: { category: 'EventHandlers' } };
export const onProgressCapture = { table: { category: 'EventHandlers' } };
export const onRateChange = { table: { category: 'EventHandlers' } };
export const onRateChangeCapture = { table: { category: 'EventHandlers' } };
export const onReset = { table: { category: 'EventHandlers' } };
export const onResetCapture = { table: { category: 'EventHandlers' } };
export const onScroll = { table: { category: 'EventHandlers' } };
export const onScrollCapture = { table: { category: 'EventHandlers' } };
export const onSeeked = { table: { category: 'EventHandlers' } };
export const onSeekedCapture = { table: { category: 'EventHandlers' } };
export const onSeeking = { table: { category: 'EventHandlers' } };
export const onSeekingCapture = { table: { category: 'EventHandlers' } };
export const onSelect = { table: { category: 'EventHandlers' } };
export const onSelectCapture = { table: { category: 'EventHandlers' } };
export const onStalled = { table: { category: 'EventHandlers' } };
export const onStalledCapture = { table: { category: 'EventHandlers' } };
export const onSubmit = { table: { category: 'EventHandlers' } };
export const onSubmitCapture = { table: { category: 'EventHandlers' } };
export const onSuspend = { table: { category: 'EventHandlers' } };
export const onSuspendCapture = { table: { category: 'EventHandlers' } };
export const onTimeUpdate = { table: { category: 'EventHandlers' } };
export const onTimeUpdateCapture = { table: { category: 'EventHandlers' } };
export const onTouchCancel = { table: { category: 'EventHandlers' } };
export const onTouchCancelCapture = { table: { category: 'EventHandlers' } };
export const onTouchEnd = { table: { category: 'EventHandlers' } };
export const onTouchEndCapture = { table: { category: 'EventHandlers' } };
export const onTouchMove = { table: { category: 'EventHandlers' } };
export const onTouchMoveCapture = { table: { category: 'EventHandlers' } };
export const onTouchStart = { table: { category: 'EventHandlers' } };
export const onTouchStartCapture = { table: { category: 'EventHandlers' } };
export const onTransitionEnd = { table: { category: 'EventHandlers' } };
export const onTransitionEndCapture = { table: { category: 'EventHandlers' } };
export const onVolumeChange = { table: { category: 'EventHandlers' } };
export const onVolumeChangeCapture = { table: { category: 'EventHandlers' } };
export const onWaiting = { table: { category: 'EventHandlers' } };
export const onWaitingCapture = { table: { category: 'EventHandlers' } };
export const onWheel = { table: { category: 'EventHandlers' } };
export const onWheelCapture = { table: { category: 'EventHandlers' } };

// Caveat: If any prop is added here, it would falsely be add to the documentation of the component
// where this group is used. If the group is to be extended, then only single props should be imported
// by each component that does not use all of them.
export const EventHandlers: StorybookArgs = {
  onAbort,
  onAbortCapture,
  onAnimationEnd,
  onAnimationEndCapture,
  onAnimationIteration,
  onAnimationIterationCapture,
  onAnimationStart,
  onAnimationStartCapture,
  onAuxClick,
  onAuxClickCapture,
  onBeforeInput,
  onBeforeInputCapture,
  onBlur,
  onBlurCapture,
  onCanPlay,
  onCanPlayCapture,
  onCanPlayThrough,
  onCanPlayThroughCapture,
  onChange,
  onChangeCapture,
  onClick,
  onClickCapture,
  onCompositionEnd,
  onCompositionEndCapture,
  onCompositionStart,
  onCompositionStartCapture,
  onCompositionUpdate,
  onCompositionUpdateCapture,
  onContextMenu,
  onContextMenuCapture,
  onCopy,
  onCopyCapture,
  onCut,
  onCutCapture,
  onDoubleClick,
  onDoubleClickCapture,
  onDrag,
  onDragCapture,
  onDragEnd,
  onDragEndCapture,
  onDragEnter,
  onDragEnterCapture,
  onDragExit,
  onDragExitCapture,
  onDragLeave,
  onDragLeaveCapture,
  onDragOver,
  onDragOverCapture,
  onDragStart,
  onDragStartCapture,
  onDrop,
  onDropCapture,
  onDurationChange,
  onDurationChangeCapture,
  onEmptied,
  onEmptiedCapture,
  onEncrypted,
  onEncryptedCapture,
  onEnded,
  onEndedCapture,
  onError,
  onErrorCapture,
  onFocus,
  onFocusCapture,
  onGotPointerCapture,
  onGotPointerCaptureCapture,
  onInput,
  onInputCapture,
  onInvalid,
  onInvalidCapture,
  onKeyDown,
  onKeyDownCapture,
  onKeyPress,
  onKeyPressCapture,
  onKeyUp,
  onKeyUpCapture,
  onLoad,
  onLoadCapture,
  onLoadStart,
  onLoadStartCapture,
  onLoadedData,
  onLoadedDataCapture,
  onLoadedMetadata,
  onLoadedMetadataCapture,
  onLostPointerCapture,
  onLostPointerCaptureCapture,
  onMouseDown,
  onMouseDownCapture,
  onMouseEnter,
  onMouseLeave,
  onMouseMove,
  onMouseMoveCapture,
  onMouseOut,
  onMouseOutCapture,
  onMouseOver,
  onMouseOverCapture,
  onMouseUp,
  onMouseUpCapture,
  onPaste,
  onPasteCapture,
  onPause,
  onPauseCapture,
  onPlay,
  onPlayCapture,
  onPlaying,
  onPlayingCapture,
  onPointerCancel,
  onPointerCancelCapture,
  onPointerDown,
  onPointerDownCapture,
  onPointerEnter,
  onPointerEnterCapture,
  onPointerLeave,
  onPointerLeaveCapture,
  onPointerMove,
  onPointerMoveCapture,
  onPointerOut,
  onPointerOutCapture,
  onPointerOver,
  onPointerOverCapture,
  onPointerUp,
  onPointerUpCapture,
  onProgress,
  onProgressCapture,
  onRateChange,
  onRateChangeCapture,
  onReset,
  onResetCapture,
  onScroll,
  onScrollCapture,
  onSeeked,
  onSeekedCapture,
  onSeeking,
  onSeekingCapture,
  onSelect,
  onSelectCapture,
  onStalled,
  onStalledCapture,
  onSubmit,
  onSubmitCapture,
  onSuspend,
  onSuspendCapture,
  onTimeUpdate,
  onTimeUpdateCapture,
  onTouchCancel,
  onTouchCancelCapture,
  onTouchEnd,
  onTouchEndCapture,
  onTouchMove,
  onTouchMoveCapture,
  onTouchStart,
  onTouchStartCapture,
  onTransitionEnd,
  onTransitionEndCapture,
  onVolumeChange,
  onVolumeChangeCapture,
  onWaiting,
  onWaitingCapture,
  onWheel,
  onWheelCapture,
};



================================================
FILE: storybook/stories/API/props/LabelListProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';

export const LabelListProps: StorybookArgs = {
  dataKey: {
    description: 'The key of a group of label values in data.',
    table: {
      type: {
        summary: 'String | Number | Function',
      },
      category: 'General',
    },
  },
  valueAccessor: {
    description: 'The accessor function to get the value of each label.',
    table: {
      category: 'General',
    },
  },
  content: {
    description:
      'If set a React element, the option is the customized react element of rendering each label. ' +
      'If set a function, the function will be called to render each label content.',
    defaultValue: null,
    table: {
      category: 'General',
      type: {
        summary: 'ReactElement | Function',
        detail: '<Label content={<CustomizedLabel external={external} />} />\n<Label content={renderLabel} />',
      },
    },
  },
  position: {
    description: 'The position of each label relative to it view box.',
    table: {
      type: {
        summary:
          '"top" | "left" | "right" | "bottom" | "inside" | "outside" | "insideLeft" | ' +
          '"insideRight" | "insideTop" | "insideBottom" | "insideTopLeft" | ' +
          '"insideBottomLeft" | "insideTopRight" | "insideBottomRight" | ' +
          '"insideStart" | "insideEnd" | "end" | "center" | "centerTop" | "centerBottom" | "middle"',
      },
      category: 'General',
    },
  },
  offset: {
    description: 'The offset to the specified "position"',
    defaultValue: 5,
    table: {
      type: {
        summary: 'Number',
      },
      category: 'General',
    },
  },
  formatter: {
    description: 'The formatter function of label value which has only one parameter - the value of label.',
    table: {
      type: {
        summary: 'Function',
      },
      category: 'General',
    },
  },
  data: {
    description: 'The data input to the charts.',
    defaultValue: 5,
    table: {
      type: {
        summary: 'Number',
      },
      category: 'General',
    },
  },
  clockWise: {
    description: 'The parameter to calculate the view box of label in radial charts.',
    table: {
      type: {
        summary: 'Boolean',
      },
      category: 'General',
    },
  },
  id: {
    description:
      'The unique id of this component, which will be used to generate ' +
      'unique clip path id internally. This props is suggested to be set in SSR.',
    table: {
      category: 'General',
    },
  },
};



================================================
FILE: storybook/stories/API/props/Legend.ts
================================================
import { StorybookArg, StorybookArgs } from '../../../StorybookArgs';

export const legendType: StorybookArg = {
  description: "The type of icon in legend. If set to 'none', no legend item will be rendered.",
  table: {
    type: {
      summary: 'line | plainline | square | rect| circle | cross | diamond | square | star | triangle | wye | none',
    },
    defaultValue: 'line',
    category: 'Style',
  },
};

// Caveat: If any prop is added here, it would falsely be add to the documentation of the component
// where this group is used. If the group is to be extended, then only single props should be imported
// by each component that does not use all of them.
export const LegendProps: StorybookArgs = {
  width: {
    description: 'The width of legend.',
    table: {
      type: {
        summary: 'Number',
      },
      category: 'General',
    },
  },
  height: {
    description: 'The height of legend.',
    table: {
      type: {
        summary: 'Number',
      },
      category: 'General',
    },
  },
  layout: {
    description: 'The layout of legend items.',
    defaultValue: 'horizontal',
    table: {
      type: {
        summary: 'horizontal | vertical',
      },
      category: 'General',
    },
  },
  align: {
    description: `Sets horizontal position of the Legend relative to the chart:

- \`left\` shows the Legend to the left of the chart, and chart width reduces automatically to make space for it.
- \`right\` shows the Legend to the right of the chart, and chart width reduces automatically.
- \`center\` shows the Legend in the middle of chart, and chart width remains unchanged.

The exact behavior changes depending on \`verticalAlign\` prop.`,
    defaultValue: 'center',
    table: {
      type: {
        summary: 'left | center | right',
      },
      category: 'General',
    },
  },
  verticalAlign: {
    description: `Sets vertical position of the Legend relative to the chart:

- \`bottom\` shows the Legend below chart, and chart height reduces automatically to make space for it.
- \`top\` shows the Legend above chart, and chart height reduces automatically.
- \`middle\` shows the Legend in the middle of chart, covering other content, and chart height remains unchanged.

The exact behavior changes depending on \`align\` prop.`,
    table: {
      type: {
        summary: 'top | middle | bottom',
      },
      category: 'General',
    },
  },
  iconSize: {
    description: 'The size of icon in each legend item.',
    defaultValue: 14,
    table: {
      type: {
        summary: 'Number',
      },
      category: 'General',
    },
  },
  iconType: {
    description: 'The type of icon in each legend item.',
    defaultValue: 'line',
    table: {
      type: {
        summary: 'line | plainline | square | rect | circle | cross | diamond | star | triangle | wye',
      },
      category: 'General',
    },
  },
  itemSorter: {
    description: `How should Legend items be sorted.
      Can be either a string (the name of the key to sort by) or a function.
      The function should return one value to be compared. This sorts always in ascending order.`,
    defaultValue: 'value',
    options: ['value', 'dataKey'],
    control: {
      type: 'inline-radio',
    },
    table: {
      category: 'Content',
      type: {
        summary: 'value | dataKey | Function',
      },
    },
  },
  content: {
    description: `If set to a React element, the option will be used to render the legend.
    If set to a function, the function will be called to render the legend's content.`,
    table: {
      type: {
        summary: 'ReactElement | Function',
        detail: `<Legend content={<CustomizedLegend external={external} />} />

        const renderLegend = (props) => {
          const { payload } = props;

          return (
            <ul>
              {
                payload.map((entry, index) => (
                  <li key={'item'-index}>{entry.value}</li>
                ))
              }
            </ul>
          );
        }
        <Legend content={renderLegend} />`,
      },
      category: 'General',
    },
  },
  formatter: {
    description: 'The formatter function of each text in legend.',
    table: {
      type: {
        summary: 'Function',
        detail: '(value, entry, index) => ()',
      },
      category: 'General',
    },
  },
  wrapperStyle: {
    description: `The style of legend container which is a "position: absolute;" div element.
    Because the position of legend is quite flexible, so you can change the position by the value of top, left, right, bottom in this option.
    And the format of wrapperStyle is the same as React inline style.`,
    table: {
      type: {
        summary: 'Object',
      },
      category: 'General',
    },
  },
  portal: {
    description: `If portal is defined, then Legend will use this element as a target
    for rendering using React Portal: https://react.dev/reference/react-dom/createPortal.
    If this is undefined then Legend renders inside the recharts-wrapper element with absolute positioning.`,
    table: {
      category: 'Position',
      type: {
        summary: 'HTMLElement | null',
      },
    },
  },
};



================================================
FILE: storybook/stories/API/props/PolarChartProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';
import { CategoricalChartProps } from './ChartProps';

export const PolarChartProps: StorybookArgs = {
  ...CategoricalChartProps,
  cx: {
    description: 'The x-coordinate of the center of the circle.',
    defaultValue: '50%',
    table: {
      type: {
        summary: 'number | string',
      },
      category: 'Polar',
    },
  },
  cy: {
    description: 'The y-coordinate of the center of the circle.',
    defaultValue: '50%',
    table: {
      type: {
        summary: 'number | string',
      },
      category: 'Polar',
    },
  },
  innerRadius: {
    description: 'The inner radius of polar chart.',
    defaultValue: 0,
    table: {
      type: {
        summary: 'number',
      },
      category: 'Polar',
    },
  },
  outerRadius: {
    description: 'The outer radius of polar chart.',
    defaultValue: '80%',
    table: {
      type: {
        summary: 'number',
      },
      category: 'Polar',
    },
  },
  startAngle: {
    description: 'The start angle of polar chart.',
    defaultValue: 90,
    table: {
      type: {
        summary: 'number',
      },
      category: 'Polar',
    },
  },
  endAngle: {
    description: 'The end angle of polar chart.',
    defaultValue: -270,
    table: {
      type: {
        summary: 'number',
      },
      category: 'Polar',
    },
  },
};



================================================
FILE: storybook/stories/API/props/PolarComponentShared.ts
================================================
import { StorybookArg, StorybookArgs } from '../../../StorybookArgs';
import { dataKey } from './CartesianComponentShared';

export const General: StorybookArgs = {
  angleAxisId: {
    description: 'The id of angle axis which is corresponding to the data.',
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
  stackId: {
    description: 'The stack id of bar, when two bars have the same stackId, then two bars are stacked in order.',
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
  radiusAxisId: {
    description: 'The id of radius axis which is corresponding to the data.',
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
  dataKey,
};

export const data: StorybookArg = { table: { category: 'Internal' } };

export const Internal: StorybookArgs = {
  data,
};



================================================
FILE: storybook/stories/API/props/RadarChartProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';
import { CategoricalChartProps } from './ChartProps';

export const RadarChartProps: StorybookArgs = {
  ...CategoricalChartProps,
  cx: {
    description: 'The x-coordinate of the center of the circle.',
    defaultValue: '50%',
    table: {
      type: {
        summary: 'number | string',
      },
      category: 'Polar',
    },
  },
  cy: {
    description: 'The y-coordinate of the center of the circle.',
    defaultValue: '50%',
    table: {
      type: {
        summary: 'number | string',
      },
      category: 'Polar',
    },
  },
};



================================================
FILE: storybook/stories/API/props/RadialBarChartProps.ts
================================================
import { BarChartProps } from './BarChartProps';
import { StorybookArgs } from '../../../StorybookArgs';
import { PolarChartProps } from './PolarChartProps';

export const RadialBarChartProps: StorybookArgs = {
  ...BarChartProps,
  ...PolarChartProps,
  startAngle: {
    ...PolarChartProps.startAngle,
    defaultValue: 0,
  },
  endAngle: {
    ...PolarChartProps.endAngle,
    defaultValue: 360,
  },
};



================================================
FILE: storybook/stories/API/props/RadialBarProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';
import { tooltipType } from './Tooltip';
import { EventHandlers } from './EventHandlers';
import { AnimationProps } from './AnimationProps';
import { legendType } from './Legend';
import { General as GeneralProps } from './PolarComponentShared';
import { RadialBarStyle } from './Styles';

export const RadialBarProps: StorybookArgs = {
  tooltipType,
  ...EventHandlers,
  ...AnimationProps,
  legendType,
  ...GeneralProps,
  ...RadialBarStyle,
  // Deprecated
  dangerouslySetInnerHTML: { table: { category: 'Deprecated' }, hide: true, disable: true },
  startAngle: {
    table: { category: 'Deprecated' },
    hide: true,
    disable: true,
  },
  endAngle: {
    table: { category: 'Deprecated' },
    hide: true,
    disable: true,
  },
};



================================================
FILE: storybook/stories/API/props/RectangleProps.ts
================================================
/*
 * This file both exports the documentation of shared props separately, to be reused in places where only single props
 * are documented, as well as grouped in case a whole group is needed.
 */

import { StorybookArg, StorybookArgs } from '../../../StorybookArgs';

export const radius: StorybookArg = {
  description:
    'If set a value, the option is the radius of all the rounderd corners. If set a array, the option' +
    ' are in turn the radiuses of top-left corner, top-right corner, bottom-right corner, bottom-left' +
    ' corner.',
  table: {
    type: { summary: 'number | number[]' },
    defaultValue: 0,
    category: 'Style',
  },
};

export const isUpdateAnimationActive: StorybookArg = {
  description: 'If set false, animation of component updates will be disabled.',
  table: { category: 'Animation' },
};

/**
 * Caveat: If any prop is added here, it would falsely be add to the documentation of the component
 * where this group is used. If the group is to be extended, then only single props should be imported
 * by each component that does not use all of them.
 * */
export const RectangleProps: StorybookArgs = {
  radius,
  isUpdateAnimationActive,
};



================================================
FILE: storybook/stories/API/props/ReferenceComponentShared.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';

export const ReferenceComponentStyle: StorybookArgs = {
  ifOverflow: {
    description: `Defines how to draw the reference component if it falls partly outside the canvas.
    If set to 'discard', the reference component will not be drawn at all. If set to 'hidden', the
    reference component will be clipped to the canvas. If set to 'visible', the reference component
    will be drawn completely. If set to 'extendDomain', the domain of the overflown axis will be
    extended such that the reference component fits into the canvas.`,
    table: { type: { summary: "'discard' | 'hidden' | 'visible' | 'extendDomain'" }, category: 'Style' },
    defaultValue: 'discard',
  },
};

export const ReferenceComponentGeneralArgs: StorybookArgs = {
  xAxisId: {
    description: 'The id of x-axis which is corresponding to the data.',
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
  yAxisId: {
    description: 'The id of y-axis which is corresponding to the data.',
    table: { type: { summary: 'string | number' }, category: 'General' },
  },
};

export const ReferenceComponentInternalArgs: StorybookArgs = {
  xAxis: {
    description: 'The configuration of the corresponding x-axis, usually calculated internally.',
    table: { type: { summary: 'Object' }, category: 'Internal' },
  },
  yAxis: {
    description: 'The configuration of the corresponding y-axis, usually calculated internally.',
    table: { type: { summary: 'Object' }, category: 'Internal' },
  },
  clipPathId: {
    description: `Used as the id for the clip path which is used to clip the reference component if
    'ifOverflow' is set to 'hidden'"`,
    table: { type: { summary: 'number | string' }, category: 'Internal' },
  },
};



================================================
FILE: storybook/stories/API/props/SectorProps.ts
================================================
/*
 * This file both exports the documentation of shared props separately, to be reused in places where only single props
 * are documented, as well as grouped in case a whole group is needed.
 */

import { StorybookArgs } from '../../../StorybookArgs';

/**
 * Caveat: If any prop is added here, it would falsely be add to the documentation of the component
 * where this group is used. If the group is to be extended, then only single props should be imported
 * by each component that does not use all of them.
 * */
export const SectorProps: StorybookArgs = {
  cx: {
    description: 'The x-coordinate of center.',
    table: {
      type: { summary: 'Number' },
      defaultValue: { summary: 0 },
    },
  },
  cy: {
    description: 'The y-coordinate of center.',
    table: {
      type: { summary: 'Number' },
      defaultValue: { summary: 0 },
    },
  },
  innerRadius: {
    description: 'The inner radius of the sector.',
    table: {
      type: { summary: 'Number' },
      defaultValue: { summary: 0 },
    },
  },
  outerRadius: {
    description: 'The outer radius of the sector.',
    table: {
      type: { summary: 'Number' },
      defaultValue: { summary: 0 },
    },
  },
  startAngle: {
    description: 'The start angle of the sector.',
    table: {
      type: { summary: 'Number' },
      defaultValue: { summary: 0 },
    },
  },
  endAngle: {
    description: 'The end angle of the sector.',
    table: {
      type: { summary: 'Number' },
      defaultValue: { summary: 0 },
    },
  },
  cornerRadius: {
    description: 'The radius of corners.',
    table: {
      type: { summary: 'Number' },
      defaultValue: { summary: 0 },
    },
  },
  forceCornerRadius: {
    description: 'Whether or not force to render round corner when the angle of sector is very small',
    table: {
      type: { summary: 'boolean' },
      defaultValue: { summary: 'false' },
    },
  },
};



================================================
FILE: storybook/stories/API/props/SharedAxisProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';

export const sharedAxisProps: StorybookArgs = {
  hide: {
    description: 'If set true, the axis do not display in the chart.',
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: false,
      category: 'General',
    },
  },
  includeHidden: {
    description: 'Consider hidden graphical elements when computing domain.',
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: false,
      category: 'Domain',
    },
  },
  dataKey: {
    description: 'The key of data displayed in the axis.',
    table: {
      type: {
        summary: 'String | Number | Function',
      },
      category: 'General',
    },
  },
  allowDecimals: {
    description: 'Allow the ticks to be decimals or not.',
    table: {
      type: {
        summary: 'Boolean',
      },
      defaultValue: true,
      category: 'Ticks',
    },
  },
  allowDataOverflow: {
    description: `When domain of the axis is specified and the type of the axis is 'number',
      if allowDataOverflow is set to be false, the domain will be adjusted when the minimum value
      of data is smaller than domain[0] or the maximum value of data is greater than domain[1]
      so that the axis displays all data values. If set to true, graphic elements (line, area, bars)
      will be clipped to conform to the specified domain.`,
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: false,
      category: 'Domain',
    },
  },
  allowDuplicatedCategory: {
    description: 'Allow the axis has duplicated categories or not when the type of axis is "category".',
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: true,
      category: 'Domain',
    },
  },
  angle: {
    description: 'The angle of axis ticks.',
    table: {
      type: {
        summary: 'Number',
      },
      defaultValue: 0,
      category: 'Ticks',
    },
  },
  tickCount: {
    description: "The count of axis ticks. Not used if 'type' is 'category'.",
    table: {
      type: {
        summary: 'Number',
      },
      defaultValue: 5,
      category: 'Ticks',
    },
  },
  domain: {
    description: `Specify the domain of axis when the axis is a number axis. The length of domain should be 2,
      and we will validate the values in domain. And each element in the array can be a number,
      'auto', 'dataMin', 'dataMax', a string like 'dataMin - 20', 'dataMax + 100', or a function
      that accepts a single argument and returns a number. If any element of domain is set to be
      'auto', comprehensible scale ticks will be calculated, and the final domain of axis is generated
      by the ticks. If a function, receives '[dataMin, dataMax]', and must return a computed domain
      as '[min, max]'.`,
    table: {
      type: {
        summary: 'Array | Function',
      },
      defaultValue: [0, 'auto'],
      category: 'Domain',
    },
  },
  interval: {
    description: `If set 0, all the ticks will be shown. If set preserveStart", "preserveEnd" or "preserveStartEnd",
      the ticks which is to be shown or hidden will be calculated automatically.`,
    table: {
      type: {
        summary: '"preserveStart" | "preserveEnd" | "preserveStartEnd" | Number',
      },
      defaultValue: 'preserveEnd',
      category: 'Ticks',
    },
  },
  minTickGap: {
    description: 'The minimum gap between two adjacent labels.',
    table: {
      type: {
        summary: 'Number',
      },
      defaultValue: 5,
      category: 'Ticks',
    },
  },
  axisLine: {
    description:
      'If set false, no axis line will be drawn. If set a object, the option is the configuration of axis line.',
    table: {
      type: {
        summary: 'Boolean | Object',
      },
      defaultValue: true,
      category: 'General',
    },
  },
  tickLine: {
    description:
      'If set false, no axis tick lines will be drawn. If set a object, the option is the configuration of tick lines.',
    table: {
      type: {
        summary: 'Boolean | Object',
      },
      defaultValue: true,
      category: 'Ticks',
    },
  },
  tickSize: {
    description: 'The length of tick line.',
    table: {
      type: {
        summary: 'Number',
      },
      defaultValue: 6,
      category: 'Ticks',
    },
  },
  tickFormatter: {
    description: 'The formatter function of tick.',
    table: {
      type: {
        summary: 'Function',
      },
      category: 'Ticks',
    },
  },
  ticks: {
    description: 'Set the values of axis ticks manually.',
    table: {
      type: {
        summary: 'Array',
      },
      category: 'Ticks',
    },
  },
  tick: {
    description: `If set false, no ticks will be drawn. If set a object, the option is the configuration of ticks.
      If set a React element, the option is the custom react element of drawing ticks.`,
    table: {
      type: {
        summary: 'Boolean | Object | ReactElement',
      },
      category: 'Ticks',
    },
  },
  mirror: {
    description:
      'If set true, flips ticks around the horizontal axis line, displaying the labels inside the chart instead of outside.',
    table: {
      type: {
        summary: 'Boolean',
      },
      defaultValue: false,
      category: 'General',
    },
  },
  reversed: {
    description: 'Reverses ticks left-to-right.',
    table: {
      type: {
        summary: 'Boolean',
      },
      defaultValue: false,
      category: 'General',
    },
  },
  label: {
    description: `If set a string or a number, default label will be drawn, and the option is content.
      If set a React element, the option is the custom react element of drawing label.
      If an object, the option is the props of a new Label instance.`,
    table: {
      type: {
        summary: 'String | Number | ReactElement | Object',
      },
      category: 'General',
    },
  },
  scale: {
    description: `If set to 'auto', the scale function is decided by the type of chart, and the props type.
      \nWhen set to 'time', make sure to also set type to 'number' and to include a domain.`,
    table: {
      type: {
        summary: `'auto' | 'linear' | 'pow' | 'sqrt' | 'log' | 'identity' | 'time' |
          'band' | 'point' | 'ordinal' | 'quantile' | 'quantize' | 'utc' | 'sequential' | 'threshold' | Function`,
      },
      defaultValue: 'auto',
      category: 'General',
    },
  },
  unit: {
    description:
      'The unit of data displayed in the axis. This option will be used to represent an index unit in a scatter chart.',
    table: {
      type: {
        summary: 'String | Number',
      },
      category: 'General',
    },
  },
  name: {
    description:
      'The name of data displayed in the axis. This option will be used to represent an index in a scatter chart.',
    table: {
      type: {
        summary: 'String | Number',
      },
      category: 'General',
    },
  },
  tickMargin: {
    description: 'The margin between tick line and tick.',
    table: {
      type: {
        summary: 'Number',
      },
      category: 'General',
    },
  },
};



================================================
FILE: storybook/stories/API/props/Styles.ts
================================================
// The Line props are shared between multiple components, such as the Line and the Area.
import { Args } from '@storybook/react';
import { StorybookArg, StorybookArgs } from '../../../StorybookArgs';

export const hide: StorybookArg = {
  description: 'Hides the component when true, useful when toggling visibility state via legend',
  type: { name: 'boolean' },
  control: { type: 'boolean' },
  defaultValue: false,
  table: { category: 'Style' },
};

export const GeneralStyle: StorybookArgs = {
  fill: {
    control: { type: 'color' },
    table: { category: 'Style' },
  },
  stroke: {
    control: { type: 'color' },
    table: { category: 'Style' },
  },
  strokeDasharray: {
    description: `The pattern of dashes and gaps used to paint the line.
      https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray`,
    table: {
      type: {
        summary: 'string',
      },
      category: 'Style',
    },
  },
  strokeWidth: {
    description: 'The width of the stroke.',
    table: {
      type: {
        summary: 'string | number',
      },
      category: 'Style',
    },
    defaultValue: 1,
  },
  strokeOpacity: {
    description: 'The opacity of the stroke.',
    table: {
      type: {
        summary: 'string | number',
      },
      category: 'Style',
    },
    defaultValue: 1,
  },
};

// These label props are use by radial bar as as well as line and area.
const labelDescription = `If false set, labels will not be drawn. If true set, labels will be drawn which have
the props calculated internally. If object set, labels will be drawn which have the props merged
by the internal calculated props and the option. If ReactElement set, the option can be the custom
label element. If set a function, the function will be called to render customized label.`;

const labelSummary = 'Boolean | Object | ReactElement | Function';

export const LineStyle: Args = {
  ...GeneralStyle,
  connectNulls: {
    description: 'Whether to connect a graph line across null points.',
    table: {
      type: {
        summary: 'boolean',
      },
      category: 'Style',
    },
    defaultValue: false,
  },
  dot: {
    description: `If false set, dots will not be drawn. If true set, dots will be drawn which have the props
      calculated internally. If object set, dots will be drawn which have the props merged by the internal
      calculated props and the option. If ReactElement set, the option can be the custom dot element.If set
      a function, the function will be called to render customized dot.`,
    table: {
      type: {
        summary: 'Boolean | Object | ReactElement | Function',
        detail:
          '<Line dataKey="value" dot={false} />\n' +
          '<Line dataKey="value" dot={{ stroke: \'red\', strokeWidth: 2 }} />\n' +
          '<Line dataKey="value" dot={<CustomizedDot />} />\n' +
          '<Line dataKey="value" dot={renderDot} />',
      },
      category: 'Style',
      defaultValue: true,
    },
  },
  hide,
  label: {
    description: labelDescription,
    table: {
      type: {
        summary: labelSummary,
        detail:
          '<Line dataKey="value" label />\n' +
          '<Line dataKey="value" label={{ fill: \'red\', fontSize: 20 }} />\n' +
          '<Line dataKey="value" label={<CustomizedLabel />} />\n' +
          '<Line dataKey="value" label={renderLabel} />',
      },
      defaultValue: false,
      category: 'Style',
    },
  },
  type: {
    description: `The interpolation type of line. It's the same as type in Area.
      And customized interpolation function can be set to type. https://github.com/d3/d3-shape#curves`,
    options: [
      'basis',
      'basisClosed',
      'basisOpen',
      'bumpX',
      'bumpY',
      'bump',
      'linear',
      'linearClosed',
      'natural',
      'monotoneX',
      'monotoneY',
      'monotone',
      'step',
      'stepBefore',
      'stepAfter',
    ],
    default: 'linear',
    control: {
      type: 'select',
    },
    table: {
      category: 'Style',
    },
  },
};

// Currently these props are exclusive to radial bar.
export const RadialBarStyle: Args = {
  minPointSize: {
    description: 'The minimum angle of the radial bar.',
    table: {
      type: {
        summary: 'number',
      },

      category: 'Style',
    },
    defaultValue: 0,
  },
  label: {
    description: labelDescription,
    table: {
      type: {
        summary: labelSummary,
        detail:
          '<Bar dataKey="value" label />\n' +
          "<Bar dataKey=\"value\" label={{ fill: '#333', fontSize: 15, position: 'insideStart' }} />\n" +
          '<Bar dataKey="value" label={<CustomizedLabel />} />\n' +
          '<Bar dataKey="value" label={renderLabel} />',
      },
      defaultValue: false,
      category: 'Style',
    },
  },
  // Object example is not included as the only props which seem to be supported
  // are cx and cy which not seem to provide much value.
  background: {
    description: `If false set, background of bars will not be drawn. If true set, background of bars will be
    drawn which have the props calculated internally. If object set, background of bars will be drawn which
    have the props merged by the internal calculated props and the option. If ReactElement set, the option
    can be the custom background element. If set a function, the function will be called to render customized
    background.`,
    table: {
      type: {
        summary: 'Boolean | Object | ReactElement | Function',
        detail:
          '<Bar dataKey="value" background />\n' +
          '<Bar dataKey="value" background={<CustomizedBackground />} />\n' +
          '<Bar dataKey="value" background={renderBackground} />',
      },
      defaultValue: false,
      category: 'Style',
    },
  },
  cornerRadius: {
    description: 'The radius of the corner of the bar.',
    table: {
      type: {
        summary: 'number',
      },
      defaultValue: 0,
      category: 'Style',
    },
  },
  forceCornerRadius: {
    description: 'Whether or not force to render round corner when the angle of sector is very small',
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: false,
      category: 'Style',
    },
  },
  cornerIsExternal: {
    description: `If true the rounded corner will lie outside the RadialBar, by default the rounded
        corner inside the length of the RadialBar`,
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: false,
      category: 'Style',
    },
  },
  shape: {
    description: 'Custom shape for the bar.',
    table: {
      type: {
        summary: 'ReactElement | Function',
        detail: '<Bar dataKey="value" shape={<CustomizedShape />} />\n<Bar dataKey="value" shape={renderShape} />',
      },
      category: 'Style',
    },
  },
  hide,
  activeShape: {
    description: 'The custom active shape.',
    table: {
      type: {
        summary: 'ReactElement | Function',
        detail:
          '<Bar dataKey="value" activeShape={<CustomizedActiveShape />} />\n' +
          '<Bar dataKey="value" activeShape={renderActiveShape} />',
      },
      category: 'Style',
    },
  },
  activeIndex: {
    description: 'The index of the active bar, this option can be changed in mouse event handlers.',
    table: {
      type: {
        summary: 'number | number[]',
        detail: '<Bar dataKey="value" activeIndex={0} />\n<Bar dataKey="value" activeIndex={[0, 1]} />',
      },
      category: 'Style',
    },
  },
  maxBarSize: {
    description: 'The maximum width of the bar.',
    table: {
      type: {
        summary: 'number',
      },
      category: 'Style',
    },
  },
  stroke: {
    description: 'The color of the stroke.',
    table: {
      type: {
        summary: 'string',
      },
      category: 'Style',
    },
  },
  strokeWidth: {
    description: 'The width of the stroke.',
    table: {
      type: {
        summary: 'number',
      },
      category: 'Style',
    },
  },
  strokeOpacity: {
    description: 'The opacity of the stroke.',
    table: {
      type: {
        summary: 'number',
      },
      category: 'Style',
    },
  },
  fillOpacity: {
    description: 'The opacity of the fill.',
    table: {
      type: {
        summary: 'number',
      },
      category: 'Style',
    },
  },
};



================================================
FILE: storybook/stories/API/props/TextProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';

export const TextProps: StorybookArgs = {
  content: {
    description: 'The content of text.',
  },
  lineHeight: {
    description: 'The height of each line of text in pixels.',
    table: {
      type: { summary: 'string' },
    },
  },
  breakAll: {
    description: 'Break words if the text exceeds the width.',
    defaultValue: true,
  },
  maxLines: {
    description: 'The max number of lines for text wrapping.',
    table: {
      type: { summary: 'number' },
    },
  },
  scaleToFit: {
    description: 'Scale the text to fit the width or not.',
    table: {
      type: { summary: 'boolean' },
    },
    defaultValue: false,
  },

  angle: {
    description: 'The rotate angle of Text. (Optional)',
    table: {
      type: { summary: 'number' },
    },
  },

  width: {
    description:
      'The width of Text. When the width is specified to be a number,' +
      ' the text will warp auto by calculating the width of text. (Optional)',
    table: {
      type: { summary: 'number' },
    },
  },

  textAnchor: {
    table: {
      type: { summary: 'start | middle | end | inherit' },
    },
    defaultValue: 'start',
  },

  verticalAnchor: {
    table: {
      type: {
        summary: 'start | middle | end ',
      },
    },
    defaultValue: 'end',
  },
};



================================================
FILE: storybook/stories/API/props/Tooltip.ts
================================================
import { StorybookArg, StorybookArgs } from '../../../StorybookArgs';

export const tooltipType: StorybookArg = {
  description: `If set to be 'none', no series data is shown in tooltip.`,
  table: { category: 'Tooltip' },
  control: { type: 'select' },
  options: ['responsive', 'none'],
};

export const activeDot: StorybookArg = {
  description: `The active dot is shown when a user enters a line chart and this chart has tooltip.
      If set to false, no active dot will be drawn. If set to true, active dot will be drawn with the
      props calculated internally. If passed an object, active dot will be drawn, and the internally
      calculated props will be merged with the key value pairs of the passed object. If passed a ReactElement,
      the option can be the custom active dot element. If passed a function, the function will be called to
      render a customized active dot.`,
  table: {
    type: {
      summary: 'Boolean | Object | ReactElement | Function',
      detail: `'<Line dataKey="value" activeDot={false} />\n' +
      '<Line dataKey="value" activeDot={{ stroke: 'red', strokeWidth: 2 }} />\n' +
      '<Line dataKey="value" activeDot={<CustomizedDot />} />\n' +
      '<Line dataKey="value" activeDot={renderDot} />'`,
    },
    defaultValue: true,
    category: 'Tooltip',
  },
};

export const ResponsiveProps: StorybookArgs = {
  activeDot,
  tooltipType,
};



================================================
FILE: storybook/stories/API/props/TooltipProps.tsx
================================================
import { StorybookArgs } from '../../../StorybookArgs';

export const TooltipProps: StorybookArgs = {
  active: {
    description: `When set to true, the tooltip will remain visible, even after the user has moved off of the chart.
      Set \`defaultIndex\` if you want the tooltip to be visible by default, before first mouse enter.`,
    defaultValue: undefined,
    options: [true, false, undefined],
    control: {
      type: 'inline-radio',
    },
  },
  defaultIndex: {
    description: 'The index where the Tooltip should appear *before* the user has interacted with the chart.',
  },
  separator: {
    description: 'The separator between name and value.',
    defaultValue: ' : ',
    table: {
      type: { summary: 'string' },
      category: 'Content',
    },
  },
  offset: {
    description: `Gap (in px) between the position of tooltip and the active position.
      This number sets both horizontal and vertical offsets.
      The active position depends on the data point, and mouse cursor position.
      The offset can be negative.`,
    defaultValue: 10,
    table: {
      type: { summary: 'number' },
      category: 'Position',
    },
  },
  filterNull: {
    description: "When an item of the payload has value null or undefined, this item won't be displayed.",
    table: { type: { summary: 'boolean' }, category: 'Content' },
    defaultValue: true,
  },
  itemStyle: {
    description: 'The style of default tooltip content item which is a li element.',
    defaultValue: {},
    table: { type: { summary: 'Object' }, category: 'Styles' },
  },
  wrapperStyle: {
    description: 'The style of tooltip wrapper which is a dom element.',
    defaultValue: {},
    table: { type: { summary: 'Object' }, category: 'Styles' },
  },
  contentStyle: {
    description: 'The style of tooltip content which is a dom element.',
    defaultValue: {},
    table: { type: { summary: 'Object' }, category: 'Styles' },
  },
  labelStyle: {
    description: 'The style of default tooltip label which is a p element.',
    defaultValue: {},
    table: { type: { summary: 'Object' }, category: 'Styles' },
  },
  cursor: {
    description: `If set false, no cursor will be drawn when tooltip is active.
    If set an object, the option is the configuration of cursor.
    If set a React element, the option is the custom react element of drawing cursor.`,
    defaultValue: true,
    table: {
      type: {
        summary: 'Object | ReactElement | boolean',
      },
      category: 'Styles',
    },
  },
  viewBox: {
    description: `The box of viewing area.
    Has the shape of { x: number, y: number, width: number, height: number }.
    Usually calculated internally.`,
    defaultValue: { x: 0, y: 0, height: 0, width: 0 },
    table: {
      type: {
        summary: 'Object',
        detail: '{ x: number, y: number, width: number, height: number },',
      },
      category: 'Internal',
    },
  },
  allowEscapeViewBox: {
    description: 'Allows the tooltip to extend beyond the viewBox of the chart itself.',
    defaultValue: { x: false, y: false },
    table: {
      type: {
        summary: 'Object',
        detail: '{ x: boolean, y: boolean }',
      },
      category: 'Styles',
    },
  },
  position: {
    description: 'If this field is set, the tooltip position will be fixed and will not move anymore.',
    table: {
      category: 'Position',
      type: {
        summary: 'Object',
        detail: '{ x: number, y: number }',
      },
    },
  },
  coordinate: {
    description: 'The coordinate of tooltip position, usually calculated internally.',
    table: {
      category: 'Internal',
      type: {
        summary: 'Object',
        detail: '{ x: number, y: number }',
      },
    },
    defaultValue: '{ x: 0, y: 0 }',
  },
  payload: {
    description: 'The source data of the content to be displayed in the tooltip, usually calculated internally.',
    table: {
      category: 'Internal',
      type: {
        summary: 'Array',
        detail: "[{ name: '05-01', value: 12, unit: 'kg' }]",
      },
    },
  },
  label: {
    description: 'The label value which is active now, usually calculated internally.',
    table: {
      category: 'Internal',
      type: {
        summary: 'string | number',
      },
    },
  },
  content: {
    description: `If set a React element, the option is the custom react element of rendering tooltip.
       If set a function, the function will be called to render tooltip content.`,
    table: {
      type: {
        summary: 'ReactElement | Function',
        detail: `<Tooltip content={<CustomizedTooltip external={external} />} />
        <Tooltip content={renderTooltip} />`,
      },
      category: 'Content',
    },
  },
  formatter: {
    description: `The formatter function of value in tooltip.
    If you return an array, the first entry will be the formatted "value",
    and the second entry will be the formatted "name". If you return a nullish value
    nothing will be rendered for the tooltip name or value.`,
    table: {
      category: 'Content',
      type: {
        summary: 'Function',
        detail: `(value, name, props) => "formatted value"
        (value, name, props) => ["formatted value", "formatted name"]`,
      },
    },
  },
  labelFormatter: {
    description: 'The formatter function of label in tooltip.',
    table: {
      category: 'Content',
      type: {
        summary: 'Function',
      },
    },
  },
  itemSorter: {
    description: `How should payload inside tooltip be sorted.
      Can be either a string (the name of the key to sort by) or a function.
      The function should return one value to be compared. This sorts always in ascending order.`,
    defaultValue: 'name',
    options: ['name', 'value', 'dataKey'],
    control: {
      type: 'inline-radio',
    },
    table: {
      category: 'Content',
      type: {
        summary: 'name | value | dataKey | Function',
      },
    },
  },
  isAnimationActive: {
    description: 'If set false, animation of tooltip will be disabled.',
    defaultValue: 'true in CSR, and false in SSR',
    table: {
      category: 'Content',
      type: {
        summary: 'boolean',
      },
    },
  },
  animationDuration: {
    description: 'Specifies (in milliseconds) the duration of animation.',
    defaultValue: 1500,
    table: {
      category: 'Styles',
      type: {
        summary: 'number',
      },
    },
  },
  animationEasing: {
    description: 'The type of easing function.',
    defaultValue: 'ease',
    table: {
      category: 'Styles',
      type: {
        summary: 'string',
        detail: "'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear'",
      },
    },
  },
  shared: {
    description: `If true, tooltip will appear on top of all bars on an axis tick.
    If false, tooltip will appear on individual bars.
    Currently only supported in BarChart and RadialBarChart.
    Defaults to true.`,
  },
  portal: {
    description: `If portal is defined, then Tooltip will use this element as a target
    for rendering using React Portal: https://react.dev/reference/react-dom/createPortal.
    If this is undefined then Tooltip renders inside the recharts-wrapper element with absolute positioning.`,
    table: {
      category: 'Position',
      type: {
        summary: 'HTMLElement | null',
      },
    },
  },
};



================================================
FILE: storybook/stories/API/props/utils.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';

// A helper function to generate Args for a story based on ArgsTypes objects
export const getStoryArgsFromArgsTypesObject = (argsTypes: StorybookArgs): Record<string, unknown> => {
  const args: Record<string, unknown> = {};
  Object.keys(argsTypes).forEach((key: string) => {
    if ('defaultValue' in argsTypes[key]) {
      args[key] = argsTypes[key].defaultValue;
    } else if ('table' in argsTypes[key] && 'defaultValue' in argsTypes[key].table) {
      args[key] = argsTypes[key].table.defaultValue;
    }
  });
  return args;
};



================================================
FILE: storybook/stories/API/props/XAxisProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';
import { sharedAxisProps } from './SharedAxisProps';

export const XAxisProps: StorybookArgs = {
  ...sharedAxisProps,
  hide: {
    description: 'If set true, the axis do not display in the chart.',
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: false,
      category: 'General',
    },
  },
  includeHidden: {
    description: 'Consider hidden graphical elements when computing domain.',
    table: {
      type: {
        summary: 'boolean',
      },
      defaultValue: false,
      category: 'Domain',
    },
  },
  dataKey: {
    description: 'The key of data displayed in the axis.',
    table: {
      type: {
        summary: 'String | Number | Function',
      },
      category: 'General',
    },
  },
  xAxisId: {
    description: 'The unique id of x-axis.',
    table: {
      type: {
        summary: 'String | Number',
      },
      defaultValue: 0,
      category: 'General',
    },
  },
  height: {
    description: 'The height of axis element in pixels.',
    table: {
      type: {
        summary: 'Number',
      },
      defaultValue: 30,
      category: 'Layout',
    },
  },
  orientation: {
    description: 'The orientation of axis',
    table: {
      type: {
        summary: "'bottom' , 'top'",
      },
      defaultValue: 'bottom',
      category: 'Layout',
    },
  },
  type: {
    description: 'The type of axis.',
    table: {
      type: {
        summary: "'number' | 'category'",
      },
      defaultValue: 'category',
      category: 'General',
    },
  },
  padding: {
    description: 'Specify the padding of x-axis.',
    table: {
      type: {
        summary: 'Object | "gap" | "no-gap"',
      },
      defaultValue: { left: 0, right: 0 },
      category: 'Ticks',
    },
  },
};



================================================
FILE: storybook/stories/API/props/YAxisProps.ts
================================================
import { StorybookArgs } from '../../../StorybookArgs';
import { sharedAxisProps } from './SharedAxisProps';

export const YAxisProps: StorybookArgs = {
  ...sharedAxisProps,
  xAxisId: {
    description: 'The unique id of x-axis.',
    table: {
      type: {
        summary: 'String | Number',
      },
      defaultValue: 0,
      category: 'General',
    },
  },
  width: {
    description: 'The width of axis element in pixels. When set to "auto", the width will be calculated dynamically.',
    table: {
      type: {
        summary: 'Number | "auto"',
      },
      defaultValue: 60,
      category: 'Layout',
    },
    control: {
      type: 'text',
    },
  },
  orientation: {
    description: 'The orientation of axis',
    table: {
      type: {
        summary: "'left' , 'right'",
      },
      defaultValue: 'left',
      category: 'Layout',
    },
  },
  type: {
    description: 'The type of axis.',
    table: {
      type: {
        summary: "'number' | 'category'",
      },
      defaultValue: 'number',
      category: 'General',
    },
  },
  padding: {
    description: 'Specify the padding of x-axis.',
    table: {
      type: {
        summary: '{ top: number, bottom: number }',
      },
      defaultValue: { top: 0, bottom: 0 },
      category: 'Ticks',
    },
  },
};



================================================
FILE: storybook/stories/API/shapes/Cross.mdx
================================================
import { ArgTypes, Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Cross.stories';

# Cross

The Cross is a shape that is valid in the context of any SVG as well as within the `<Customized />` component.
This is a building block used internally to recharts to create cursor components, etc.

```jsx
<Customized component={<Cross {...crossProps} />} />
```

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Properties

The following table shows a complete list of all properties of the Cross.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/shapes/Cross.stories.tsx
================================================
import React from 'react';
import { Cross, Customized, ComposedChart, ResponsiveContainer } from '../../../../src';
import { GeneralStyle } from '../props/Styles';

export default {
  component: Cross,
  argTypes: {
    y: {
      description: 'The y-coordinate of the horizontal line of the cross.',
      table: {
        type: { summary: 'number' },
      },
    },
    x: {
      description: 'The x-coordinate of the vertical line of the cross.',
      table: {
        type: { summary: 'number' },
      },
    },
    top: {
      description: 'The y-coordinate of the top left point in the boundary box of the cross.',
      table: {
        type: { summary: 'number' },
      },
    },
    left: {
      description: 'The x-coordinate of the top left point in the boundary box of the cross.',
      table: {
        type: { summary: 'number' },
      },
    },
    height: {
      description: 'The height of the vertical line of the cross.',
      table: {
        type: { summary: 'number' },
      },
    },
    width: {
      description: 'The width of the horizontal line of the cross.',
      table: {
        type: { summary: 'number' },
      },
    },
    // TODO: Document further SVGProps as well.
    ...GeneralStyle,
  },
};

export const API = {
  render: (args: Record<string, any>) => {
    return (
      <ResponsiveContainer width="100%" height={500}>
        <ComposedChart
          width={500}
          height={300}
          margin={{
            top: 5,
            right: 30,
            left: 20,
            bottom: 5,
          }}
        >
          <Customized component={<Cross {...args} />} />
        </ComposedChart>
      </ResponsiveContainer>
    );
  },
  args: {
    y: 100,
    x: 500,
    top: 0,
    left: 0,
    height: 1000,
    width: 1000,
    stroke: '#000',
    fill: 'none',
    strokeDasharray: '3 3',
    strokeWidth: 10,
    strokeOpacity: 0.5,
  },
};



================================================
FILE: storybook/stories/API/shapes/Curve.mdx
================================================
import { ArgTypes, Meta, Story, Canvas, Controls } from '@storybook/blocks';
import * as ComponentStories from './Curve.stories';

# Curve

The Curve is a shape that is valid in the context of any SVG as well as within the `<Customized />` component.
This is a building block used internally to recharts to create `<Area />`, etc.

```jsx
<Customized component={<Curve {...crossProps} />} />
```

<Meta of={ComponentStories} />

<Canvas>
  <Story name="API" of={ComponentStories} />
</Canvas>

## Properties

The following table shows a complete list of all properties of the Curve.

<Controls of={ComponentStories.API} />



================================================
FILE: storybook/stories/API/shapes/Curve.stories.tsx
================================================
import React from 'react';
import { Curve, Customized, ComposedChart,